#### **"서버리스(Serverless)"란 무엇인가?**

- **여전히 서버에서 실행됨:** AWS가 관리하는 추상화된 물리적 하드웨어 위에서 돌아간다. (서버가 아예 없는 게 아님)
- **한 번에 몇 초 또는 몇 분간 실행:** 필요할 때만 잠깐 실행되는 임시 컴퓨팅이며, 실행된 시간만큼만 비용이 청구된다.
- **이벤트에 반응:** API Gateway 호출, S3 파일 업로드, DynamoDB 변경 사항 같은 소스에 의해 자동으로 실행(트리거)된다.
- **수동으로 실행(트리거) 가능:** AWS 콘솔, CLI 명령어, 또는 SDK 코드 호출을 통해 직접 실행할 수도 있다..
- **AWS 리소스에 접근 가능:** GameLift, S3, DynamoDB 같은 다른 서비스들과 안전하게 상호 작용할 수 있다..
- **AWS SDK 접근 권한:** AWS 서비스들을 매끄럽게 연동할 수 있도록 내장 라이브러리를 제공한다..
- **다양한 프로그래밍 언어 지원:** Node.js, Python, Java, Go, C#, Ruby 등을 지원한다.

![aws lambda : Serverless 설명](/Image/Server/AWS_Lambda_Serverless_Explain.png)

- **Client Build (Game Client):** 게임 클라이언트
    - _화살표 (요청):_ **Request with Credentials (e.g., Cognito)** - 자격 증명(예: Cognito)을 포함한 요청 전송
    - _화살표 (응답):_ **Response (e.g., Server IP/Port)** - 서버 IP 및 포트 정보 등을 응답으로 받음
- **Active Lambda Function (Executing Logic):** 활성 Lambda 함수 (현재 로직을 수행 중인 상태)
    - _연결:_ **GameLift/AWS Resources** - GameLift나 다른 AWS 리소스와 통신
- **Idle Lambda (Cold Start Potential):** 유휴 Lambda (꺼져 있는 상태, 실행 시 '콜드 스타트' 딜레이 발생 가능)
- **Parallel Scaling Lambdas (Concurrent Executions):** 병렬 확장 Lambda (요청이 몰릴 경우 여러 개가 동시에 실행됨)

##### AWS Lambda

- EC2 는 가상 PC 한 대를 통째로 임대하는 것. vs Lambda : 함수 만 올려두는 것. 누군가 호출하면 (Trigger) AWS 가 알아서 어딘가 남는 서버에서 그 코드를 딱 실행시간 만큼만 돌리고 다시 재워버린다.
- 언리얼 엔진으로 만든 게임 클라이언트(유저의 PC) 가 직접 GameLift 에게 '게임세션 만들어달라' 명령하려면 AWS 관리자 권한(key) 이 필요하다. 하지만 클라이언트에 관리자 키를 심어서 배포하면 해킹당하기 좋다. 그래서 클라이언트는 GameLift 에 집접 접근할 권한을 주지 않는다. 따라서 클라이언트는 Lambda 에게 '게임 시작하고 싶다' 라는 요청(메시지) 를 보낸다. $\to$ Lambda 는 안전한 AWS 내부망에 있으므로, GameLift 를 조작할 수 있는 권한을 가진다. $\to$ Lambda 가 대신 GameLift 에게 "게임 세션 만들어" 라고 시키고, 받은 접속 정보(IP, Port) 를 클라이언트에게 전달한다.
- 갑자기 유저 1만 명이 동시에 "게임 시작" 버튼을 눌렀다면 EC2 서버 한대라면 다운되었겠지만, Lambda 는 1만개의 코드가 동시에 병렬로 실행되어 처리해 주기 때문에 개발자가 서버 증설을 걱정할 필요가 없다.
##### Anatomy of a Lambda

```node.js
export const handler = async (event) =>
{
	const response = {
		statusCode: 200,
		body: JSON.stringify('Hello from Lambda!'),
	};
	return response;
}
```

- Handler
	- 모든 Lambda 에는 반드시 핸들러 함수가 있어야 한다.
	- AWS 에서 핸들러는 Lambda 함수의 주요 진입점이다.
	- Lambda 가 실행될 때 핸들러에서 시작된다.
- 선언부
	- export : 다른 파일이나 모듈에서 접근할 수 있도록 한다. 이를 통해 AWS 이벤트에 대응하여 핸들러 함수를 실행한다.
	- const : 함수 포인터가 가리키는 주소를 변경할 수 없다.
	- async : 함수를 비동기로 선언하여 프로그램 전체의 실행을 막지 않고도 특정 작업들이 일어날 수 있다.
	- event : Lambda 가 실행될 때 해당 함수로 전달되는 입력 값. 이것에는 함수의 호출자에 대한 정보를 포함하고 있다. Json 형식의 문자열로 전달되며, 런타임이 이를 event 라는 객체로 변환한다.
	- const response
		- c++ 에서 객체를 만들기 위해서는 먼저 Class 나 Struct 를 정의하고 그것을 new 키워드로 생성해야 하지만 자바스크립트에서는 그러한 과정을 거치지 않는다.
		- 객체 리터럴 : 코드에 값을 '문자 그대로' 타이핑하여 데이터를 만드는 형식이다. 중괄호를 치는 순간 그 자리에서 객체가 생성된다.
		- 동적 타입 : 런타입 체크를 통해 해당 변수가 어떤 자료형인지를 파악하기 때문에 타입을 미리 정하지 않는다.
		- 약 타입 (weakly typed) : 타입 검사를 하지 않고 알아서 적당히 변환해 준다. 예를 들어 숫자와 문자를 더하려고 하면 숫자를 문자로 바꿔서 이어붙이는 형식이다. 이는 유연하게 코드를 작성할 수 있지만 실행하기 전까지 타입 에어를 잡기 어렵다는 단점이 있다.
	- { }
		- StatusCode
			- response 객체의 속성(property) 이다.
			- 속성은 키-값 쌍이며, 여기에서 StatusCode 는 key 이거 200 은 값이다.
		- body
			- response 객체의 속성이다.
			- 마찬가지로 키-값 싸이며, body 는 key 이고 JSON.stringify 는 값이다.
		- JSON.stringify 는 객체를 문자열로 변환한다.

##### test aws lambda

aws lambda $\to$ dashboard $\to$ create function

![AWS_LambdaCreateSetting](/Image/Server/AWS_LambdaCreateSetting.png)

- Create Function options
	- author from scratch
		- hello world 수준의 기초적인 코드만 있는 상태에서 시작. 새로 작성하는 옵션.
	- Use a blueprint
		- AWS 가 미리 만들어둔 '샘플 템플릿' 을 사용한다.
	-  Container image
		- Docker 이미지 (소프트웨어 패키지) 를 가져와서 실행한다.
- Basic Information
	- Function name
	- Runtime
		- 작성한 코드를 실행할 언어환경
	- Architecture
		- 해당 코드가 돌아갈 CPU 의 종류를 정한다.
		- x86_64 : 일반적인 Intel/AMD CPU 환경
		- arm64 : AWS Gravition 프로세서를 사용.
- Permissions
	- Change default execution role
		- execution role (실행 역할) : 람다 함수가 사용하는 일종의 출입증
	- Create a new role with basic lambda permissions (기본 람다 권한을 가진 새 역할 생성)
		- AWS 가 알아서 이 함수를 위한 '새 출입증' 을 만들어준다.
		- 기본적으로 CloudWatch Logs 에 로그를 기록할 수 있는 권한을 준다. (함수가 실행되면서 printf 나 console.log 로 출력한 내용을 저장하기 위함). 람다를 실행하면 로그는 기본적으로 CloudWatch 로 이동한다.
		- 나중에 이 함수가 S3 나 DynamoDB 와 같은 다른 서비스에 접속해야 한다면 이 역할(Role) 에 권한을 추가해 주면 된다.

##### Lambda editor

![AWS_Lambda_Editor](/Image/Server/AWS_Lambda_Editor.png)

- Deploy (배포 버튼)
	- 컴파일하고 저장하는 것 과 비슷하다. 코드를 수정하고 이 버튼을 눌러야 실제 람다에 반영되어 실행된다.
- Test
	- 함수에 입력 데이터를 전달하여 기능을 테스트할 수 있다.
- Environment variables
	- AWS 람다는 Stateless 이다. 이는 C++ 의 Static function 과 비슷하다. 실행이 끝나면 데이터가 사라지므로, 변하지 않는 설정값 등은 환경변수에 저장해서 사용한다.

![AWS_Lambda_CreateNewTestEvent](/Image/Server/AWS_Lambda_CreateNewTestEvent.png)

- Event Name
- Invocation Type
	- Synchronous
		- 람다 함수를 호출하고, 그 함수가 작업을 다 끈내고 결과 값을 돌려줄 때까지 기다리는 (Block) 방식
		- 호출자는 람다에게 일을 시키고, 람다가 응답(Response) 를 줄 때까지 멈춰 있는다. 
	- Asynchronous
		- 람다 함수에게 처리 요청(Queue) 만 보내고, 결과를 기다리지 않고 즉시 돌아오는 방식.
		- 동작 원리 : 호출자는 람다 내부 큐(Queue) 에 작업을 넣어두고 바로 202 Accepted 같은 성공 메시지만 받는다. 실제 처리는 백그라운드에서 나중에 일어난다. 따라서 람다의 리턴값을 직접 받을 수 없다.
		- c++ 로 비유하면 별도의 쓰레드를 생성 (Detach) 하여 작업을 던져놓는 것과 비슷하다.
		- 사용자가 결과를 기다릴 필요가 없는 백그라운드 작업 이나 실패 시 자동 재시도가 필요한 작업에 사용된다.
	- 위의 코드에서 hello world 가 제대로 찍히는지, JSON 응답이 올바르게 오는지 확인하는 단계이기에 Synchronous 를 선택하여 Test 버튼을 눌렀을 때 하단에 실행 결과와 로그가 바로 표시되도록 한다. 만약 Acynchronous 를 선택하면 테스트는 성공했다고 뜨지만, 실제 함수가 리턴한 값 은 화면에서 바로 볼 수 없게 된다.
- Event Sharing Settings
	- Private
		- Lambda 콘솔 내에서, 그리고 이벤트를 생성한 당사자인 '우리'에게만 보인다는 뜻이다.
	- Shareable
		- 공유 가능이란 동일한 계정 내에서 공유 이벤트에 접근하고 사용할 권한이 있는 IAM 사용자들도 이 테스트 이벤트를 사용할 수 있게 한다는 뜻이다.
- Invoke
	- 테스트 이벤트를 저장하지 않고 람다를 실행할 수 있습니다. 단순히 입력된 값으로 람다를 실행하는 것
- Save
	- 좌 하단의 TEST EVENTS 에 Lambda 가 생성되고 편집 아이콘을 눌러 수정할 수도 있다.
- Event Json
	- 입력값 event 이다.
- Output
	- 람다 실행의 시작과 끝에 대한 Request ID, Duration 등이 있다. 여기서 알 수 있듯 Lambda 는 밀리초 단위로 요금이 청구된다.
	- 즉 함수가 실행되는데 걸리는 시간이 요금을 결정하며, 람다의 메모리 크기와 실제 사용된 메모리 양도 로그에 기록된다.
	- Init Dureation 은 람다 함수를 초기화 하는데 걸린 시간을 의미한다.

![AWS_CloudWatch_Lambda_LogEvents](/Image/Server/AWS_CloudWatch_Lambda_LogEvents.png)
- CloudWatch $\to$ Logs $\to$ Log Management $\to$ Log Events 를 보면 Lambda 에서 CloudWatch 로 전송된 다양한 메시지를 볼 수 있다. 여기에는 타임스탬프와 리포트가 포함되어 있다. 여기에는 Response 가 없는데 람다의 응답 결과는 CloudWatch 로 전송되지 않고, 오직 람다 실행과 관련된 정보만 있기 때문이다.

##### console.log

Lambda 가 CloudeWatch로 전송될 정보를 console.log 를 사용하여 직접 로그로 남길 수 있다.
```node.js
export const handler = async (event) => {
  const first_key = event.key1;
  const second_key = event.key2;

  console.log("First Key:", first_key);
  console.log("Second Key:", second_key);

  const response = {
    statusCode: 200,
    body: JSON.stringify('Hello from Lambda!'),

  };

  return response;
};
```

![AWS_Lambda_LogEvents_consoleLogResult](/Image/Server/AWS_Lambda_LogEvents_consoleLogResult.png)

console.log 로 key1 과 key2 에 속한 value 를 로그노 남겼다.

##### let

const 와 달리 let 은 나중에 값을 바꿀 수 있는 일반 변수이다. 언제든지 다른 값으로 재할당 이 가능하다. 모던 자바스크립트에서 기본적으로 const 를 사용하고, 값이 꼭 변해야 하는 경우에만 let 을 사용한다.

```node.js
export const handler = async (event) => {

  const first_key = event.key1;
  let second_key = event.key2;
  
  console.log("First Key:", first_key);
  console.log("Second Key:", second_key);

  second_key = event.key3;
  console.log("second Key after reassign:", second_key);

  const response = {
    statusCode: 200,
    body: JSON.stringify('Hello from Lambda!'),
  };
  return response;
};
```

결과
```txt
2025-12-23T18:09:48.391Z	582f6e9a-6353-448d-ae21-bafc7ce9a898	INFO	First Key: value1
2025-12-23T18:09:48.394Z	582f6e9a-6353-448d-ae21-bafc7ce9a898	INFO	Second Key: value2
2025-12-23T18:09:48.394Z	582f6e9a-6353-448d-ae21-bafc7ce9a898	INFO	second Key after reassign: value3
```


- 객체를 console.log 로 출력.
```node.js
export const handler = async (event) => {
  const newObject =  {
    first: 12,
    second: "This is the second property",
    third: event
  };
  
  console.log("newObject:", JSON.stringify(newObject));

  const response = {
    statusCode: 200,
    body: 'Hello from Lambda!',
    test : 'test:' + JSON.stringify(newObject),
  };
  return response;
};
```
- output
```output
Status: Succeeded
Test Event Name: TestHelloWorld

Response:
{
  "statusCode": 200,
  "body": "Hello from Lambda!",
  "test": "test:{\"first\":12,\"second\":\"This is the second property\",\"third\":{\"key1\":\"value1\",\"key2\":\"value2\",\"key3\":\"value3\"}}"
}
The area below shows the last 4 KB of the execution log.
Function Logs:
START RequestId: 46fb14f5-8207-4cfb-88a7-fbe6f2ebf2f2 Version: $LATEST
2025-12-23T18:17:05.928Z    46fb14f5-8207-4cfb-88a7-fbe6f2ebf2f2    INFO    newObject: {"first":12,"second":"This is the second property","third":{"key1":"value1","key2":"value2","key3":"value3"}}
END RequestId: 46fb14f5-8207-4cfb-88a7-fbe6f2ebf2f2
REPORT RequestId: 46fb14f5-8207-4cfb-88a7-fbe6f2ebf2f2  Duration: 78.07 ms  Billed Duration: 235 ms Memory Size: 128 MB Max Memory Used: 81 MB  Init Duration: 156.81 ms
Request ID: 46fb14f5-8207-4cfb-88a7-fbe6f2ebf2f2
```

- cloudwatch log
```node.js
2025-12-23T18:17:05.928Z	46fb14f5-8207-4cfb-88a7-fbe6f2ebf2f2	INFO	newObject: {
    "first": 12,
    "second": "This is the second property",
    "third": {
        "key1": "value1",
        "key2": "value2",
        "key3": "value3"
    }
}
```

##### List Fleets

- [Compute Fleet 의 이름 목록 가져오기](https://docs.aws.amazon.com/codebuild/latest/APIReference/API_ListFleets.html#CodeBuild-ListFleets-request-sortOrder)
	- Request 는 JSON 형식이다.
	- Request 에서 정렬 기준, 정렬 순서 등 설정 값을 지정할 수 있다.
	- 요청이 성공하면 HTTP 200 상태 코드와 함쎄 JSON 데이터를 반환한다.
	- Response
```JSON
{
	"fleets": [ "string" ],
	"nextToken": "string"
}
```
- 
	- fleets 는 compute fleet 이름들의 리스트이다. 최소 1개에서 최대 100개 까지 반환된다. JSON 에서 대괄호는 잠재적으로 여러 객체의모음인 배열을 나타낸다.
	- nextToken 는 fleets 리스트의 항목이 100개 이상일 경우 주어지며 함수를 호출할 때 이 토큰을 next token 이라는 입력값으로 사용할 수 있다. 그러면 다음의 100 개의 fleets 항목을 가져올 수 있게 한다.

- 새 lambda 생성
	- Author from scratch, name - ListFleets, Runtime - Node.js 24.x,  Architecture - x86_64 로 설정
	- Client GameLift 에서 무언가를 가져와야 한다. $\to$ import 키워드를 사용하여 주어진 패키지에서 특정 부분만 가져올 수 있다.
	- aws-sdk 앞에 @(at) 기호가 있는데 import 문에서 @ 기호는 스코프가 지정된 패키지(Scoped Package) 임을 나타낸다.
		- 스코프 패키지는 관련된 패키지들을 공통 네임스페이스 아래 그룹화 하는 방법이다.
		- 아래 코드의 경우 aws-sdk 가 scope 이고 client-gamelift 가 스 스코프 내의 특정 패키지 이다. 해당 패키지 않에 GameliftClient 와 ListFleetsCommand 가 정의되어 있으므로, import 로 패키지에서 가져올 수 있다.

- fleet 목록 요구 lambda 생성
	- Author from scratch, name - ListFleets, Runtime - Node.js 24.x,  Architecture - x86_64 로 설정
	- Lambda(관리자) 가 AWS SDK (도구상자) 를 꺼내서 , GameLift(작업장) 에게 Fleet 목록을 보여달라고 요청서를 보내는 과정을 진행한다
	1. import
		```node.js
		import { CodeBuildClient, ListFleetsCommand } from "@aws-sdk/client-gamelift";
		```
		- @aws-sdk : AWS 가 제공하는 거대한 도구함.
		- client-gamelift : 그 도구함 중 'GameLift' 전용 도구함
		- {CodeBuildClient, ListFleetsCommand} :client-gamalift 에서 Client(연결담당자) 와 Command(명령서 양식) 만 꺼낸다.
	2. new Client
		```node.js
		const client = new GameliftClient({ region: 'ap-northeast-2' });
		```
		- GameLift 서비스와 담당할 Client 를 생성하는데 해당 Client 에게 ap-northeast-2 에 있는 GameLift 와만 상호작용하라고 지정해 주는 것.
	3. new Command
		```node.js
		const input = {};
		const command = new ListFleetsCommand(input);
		```
		- input = {} : 명령을 내릴 때 필요한 세부 옵션. 특별한 조건 없이 다 보여줘야할 때에는 비워둔다.
		- new ListFleetsCommand(input) : 플릿 목록 조회 요청 이라는 정해진 양식에 내용을 적어서 command 를 만든다.
	4. await client.send
		```Node.js
		const response = await client.send()(Command);
		```
		- 이 작업은 네트워크를 타고 갔다 와야하기 때문에 시간이 걸린다(비동기), 그래서 awaite 를 써야 합이 돌아올 때가지 기다린다.
		- await : 담당자가 GameLift에 가서 목록을 받아올 때까지, 다음 줄로 넘어가지 않고 잠시 멈춰서 기다린다. 
		- response : 담당자가 받아온 결과물(Fleet 목록)을 이 변수에 저장한다.

- Output
```node.js
Status: Failed
Test Event Name: test_event
Response:
{
  "errorType": "AccessDeniedException",
  "errorMessage": "User: arn:aws:sts::634747716040:assumed-role/ListFleets-role-qkeciw6p/ListFleets is not authorized to perform: gamelift:ListFleets because no identity-based policy allows the gamelift:ListFleets action",
  "trace": [
    "AccessDeniedException: User: arn:aws:sts::634747716040:assumed-role/ListFleets-role-qkeciw6p/ListFleets is not authorized to perform: gamelift:ListFleets because no identity-based policy allows the gamelift:ListFleets action",
    "    at throwDefaultError (/var/runtime/node_modules/@aws-sdk/node_modules/@smithy/smithy-client/dist-cjs/index.js:422:20)",
    "    at /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/smithy-client/dist-cjs/index.js:431:5",
    "    at de_CommandError (/var/runtime/node_modules/@aws-sdk/client-gamelift/dist-cjs/index.js:4287:14)",
    "    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)",
    "    at async /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/middleware-serde/dist-cjs/index.js:36:20",
    "    at async /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/core/dist-cjs/index.js:193:18",
    "    at async /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/middleware-retry/dist-cjs/index.js:312:38",
    "    at async /var/runtime/node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js:33:22",
    "    at async BufferedInvokeProcessor.handler (file:///var/task/index.mjs:9:20)",
    "    at async BufferedInvokeProcessor.processInvoke (file:///var/runtime/index.mjs:1092:22)"
  ]
}
The area below shows the last 4 KB of the execution log.

Function Logs:
START RequestId: 37766c52-0a43-4ce3-882b-4a1e38455521 Version: $LATEST
2025-12-24T16:21:09.093Z    37766c52-0a43-4ce3-882b-4a1e38455521    ERROR   Invoke Error    {"errorType":"AccessDeniedException","errorMessage":"User: arn:aws:sts::634747716040:assumed-role/ListFleets-role-qkeciw6p/ListFleets is not authorized to perform: gamelift:ListFleets because no identity-based policy allows the gamelift:ListFleets action","name":"AccessDeniedException","$fault":"client","$metadata":{"httpStatusCode":400,"requestId":"ac16ac66-4029-44f5-b2b1-45bef3e4fcec","attempts":1,"totalRetryDelay":0},"__type":"AccessDeniedException","message":"User: arn:aws:sts::634747716040:assumed-role/ListFleets-role-qkeciw6p/ListFleets is not authorized to perform: gamelift:ListFleets because no identity-based policy allows the gamelift:ListFleets action","stack":["AccessDeniedException: User: arn:aws:sts::634747716040:assumed-role/ListFleets-role-qkeciw6p/ListFleets is not authorized to perform: gamelift:ListFleets because no identity-based policy allows the gamelift:ListFleets action","    at throwDefaultError (/var/runtime/node_modules/@aws-sdk/node_modules/@smithy/smithy-client/dist-cjs/index.js:422:20)","    at /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/smithy-client/dist-cjs/index.js:431:5","    at de_CommandError (/var/runtime/node_modules/@aws-sdk/client-gamelift/dist-cjs/index.js:4287:14)","    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)","    at async /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/middleware-serde/dist-cjs/index.js:36:20","    at async /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/core/dist-cjs/index.js:193:18","    at async /var/runtime/node_modules/@aws-sdk/node_modules/@smithy/middleware-retry/dist-cjs/index.js:312:38","    at async /var/runtime/node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js:33:22","    at async BufferedInvokeProcessor.handler (file:///var/task/index.mjs:9:20)","    at async BufferedInvokeProcessor.processInvoke (file:///var/runtime/index.mjs:1092:22)"]}
END RequestId: 37766c52-0a43-4ce3-882b-4a1e38455521
REPORT RequestId: 37766c52-0a43-4ce3-882b-4a1e38455521  Duration: 1112.45 ms    Billed Duration: 1546 ms    Memory Size: 128 MB Max Memory Used: 104 MB Init Duration: 433.27 ms
Request ID: 37766c52-0a43-4ce3-882b-4a1e38455521
```
status가 failed 인 이유는 Error Type 에서 알 수 있듯이 gamelift:ListFleets 를 호출할 권한이 없기 때문이다.

##### 권한 설정.

- aws lambda $\to$ ListFleets $\to$ Configuration $\to$ Permissions $\to$ Resource-based policy statements 에서 권한 추가
- 또는 aws lambda $\to$ ListFleets $\to$ Configuration $\to$ Permissions $\to$ Role name 을 클릭하여 롤 자체로 이동할 수 있다. (권장 방식)
	- ![AWS_IAM_Roles](/Image/Server/AWS_IAM_Roles.png)
	- AWSLambdaBasicExecutionRole 을 열어보면 이 role 이 가진 권한을 JSON 형식으로 볼 수 있다.
	- Add permissions
		- Attach policies 로 Policy resource 를 생성할 수 있다.
		- Create inline policy 로 이 특정 Role 에 연결할 수 있는 inline policy 를 생성할 수 있다.
			- Create inline policy $\to$ Specify permissios $\to$ step1
				- Json 에서 Edit Statement 창으로 다음의 창에서 권한을 부여할 Action 을 검색하여 추가할 수 있다.![AWS_Role_AddPermissionsAction_JSON](/Image/Server/AWS_Role_AddPermissionsAction_JSON.png)
				-  visual 에서는 다음과 같이 설정할 수 있다. 특정 action 에 대한 리소스를 지정할 수 있다. 예를 들어 데이터베이스나 다른 리서스에 접근하고 싶다면, ARN 으로 식별되는 특정 리소스에만 이 정책이 접근을 허용하도록 지정할 수 있다.![AWS_Role_AddPermissionsAction_Visual](/Image/Server/AWS_Role_AddPermissionsAction_Visual.png)
			- Create inline policy $\to$ Specify permissios $\to$ step2 에서 Policy 의 이름을 설정한다.![AWS_IAM_AddPermissionsAction_Policy](/Image/Server/AWS_IAM_AddPermissionsAction_Policy.png)
			- Create Policy 를 클릭하면 Identify and Access Management(IAM) $\to$ Roles $\to$  Permission policies 에 GameLiftListFlets_Policy 가 생성된 것을 확인할 수 있다.
			```node.js
			Status: Succeeded
			Test Event Name: test_event
			Response:
			{
			  "$metadata": {
			    "httpStatusCode": 200,
			    "requestId": "59300ed0-4871-4777-a2f3-9c424e91ba85",
			    "attempts": 1,
			    "totalRetryDelay": 0
			  },
			  "FleetIds": [
			    "fleet-d71c98fe-d191-4059-9b58-eaf53be37e37"
			  ]
			}
			The area below shows the last 4 KB of the execution log.
			Function Logs:
			START RequestId: f3dccc86-9152-4a95-8bd8-cd6ddec1ead9 Version: $LATEST
			END RequestId: f3dccc86-9152-4a95-8bd8-cd6ddec1ead9
			REPORT RequestId: f3dccc86-9152-4a95-8bd8-cd6ddec1ead9  Duration: 966.11 ms Billed Duration: 1386 ms    Memory Size: 128 MB Max Memory Used: 102 MB Init Duration: 419.35 ms
			Request ID: f3dccc86-9152-4a95-8bd8-cd6ddec1ead9
			```
			- 위의 Output 결과를 보면 Succeded 가 되어 있고 FleetIds 를 가져온 것을 볼 수 있다.
			- 해당 FleetsIds 는 Amazon GameLift Servers $\to$ Anywhere Fleets 에 있는 것과 같다.
- 이를 통해 Lambda 를 통해 사실상 AWS 서비스의 API 명령을 실행할 수 있는 것이 검증되었다.

##### Try Catch

언리얼의 assertion 과 같이 lambda 에서는 try catch 를 통해 에러를 잡아낸다.
```Node.js
import { GameLiftClient, ListFleetsCommand } from "@aws-sdk/client-gamelift";

  

export const handler = async (event) => {
  const client = new GameLiftClient({region:'ap-northeast-2'});
  try {
    const input = {};
    const command = new ListFleetsCommand(input);
    const response = await client.send(command);
    return response;
  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify(error)
    };
  }
};
```
catch 는 에러를 입력값으로 받는다. 만약 try 안에서 에러가 발생하면 catch 블록이 그 에러 객체를 잡아낸다. 사용자는 해당 에러 객체를 가지고 에러 상황에 맞춰 원하는 로직을 짜면된다.
위의 예시 코드에서는 에러 발생 시에 상태코드를 지정할 수 있다. statusCode: 500 은 '서버가 요청을 처리할 수 없는 예기치 못한 상황에 빠졌다' 라는 뜻이다. 또는 JSON.stringify() 를 통해 에러 객체 자체를 문자열로 변환해 넣을 수 있다.

- 에러가 없는 상황의 Output
```node.js
Status: Succeeded
Test Event Name: test_event

Response:
{
  "$metadata": {
    "httpStatusCode": 200,
    "requestId": "26cfc6fc-95c4-4d81-a0ae-42b189e711e2",
    "attempts": 1,
    "totalRetryDelay": 0
  },
  "FleetIds": []
}

The area below shows the last 4 KB of the execution log.

Function Logs:
START RequestId: b9fcb9ea-e964-40d1-95d7-6724fca4bac5 Version: $LATEST
END RequestId: b9fcb9ea-e964-40d1-95d7-6724fca4bac5
REPORT RequestId: b9fcb9ea-e964-40d1-95d7-6724fca4bac5	Duration: 1037.44 ms	Billed Duration: 1471 ms	Memory Size: 128 MB	Max Memory Used: 104 MB	Init Duration: 433.42 ms

Request ID: b9fcb9ea-e964-40d1-95d7-6724fca4bac5
```

- GameLiftListFleets_Policy 를 삭제 한위의 에러가 생긴 상황의 Output
```node.js
Status: Succeeded
Test Event Name: test_event

Response:
{
  "statusCode": 500,
  "body": "{\"name\":\"AccessDeniedException\",\"$fault\":\"client\",\"$metadata\":{\"httpStatusCode\":400,\"requestId\":\"19b549cb-f527-482e-a528-b5df535fb757\",\"attempts\":1,\"totalRetryDelay\":0},\"__type\":\"AccessDeniedException\",\"message\":\"User: arn:aws:sts::634747716040:assumed-role/ListFleets-role-qkeciw6p/ListFleets is not authorized to perform: gamelift:ListFleets because no identity-based policy allows the gamelift:ListFleets action\"}"
}

The area below shows the last 4 KB of the execution log.

Function Logs:
START RequestId: 8d9bd325-aa45-4444-bce2-3e593bc415d0 Version: $LATEST
END RequestId: 8d9bd325-aa45-4444-bce2-3e593bc415d0
REPORT RequestId: 8d9bd325-aa45-4444-bce2-3e593bc415d0	Duration: 247.45 ms	Billed Duration: 248 ms	Memory Size: 128 MB	Max Memory Used: 104 MB

Request ID: 8d9bd325-aa45-4444-bce2-3e593bc415d0
```
Response 에서 statusCode 는 지정한 대로 500 이 출력되었지만 실제 error 메시지를 보면 httpStatusCode 가 400 인 것을 볼 수 있다.
httpStatusCode 400 은 '서버가 고장난 것이 아니라, 요청 자체가 잘못 되었다' 는 뜻이다. (ex. 권한 없음, 입력 값 틀림 등.)
이렇듯 error 나 성공 케이스를 어떻게 response 형식을 취할지 정할 수 있다.
trycatch 방식은 error 를 대할 때 효과적이고 특히 이러한 API 의 호출과 같은 asynchronouse (비동기) 함수를 다루는데 효과적이다.

IAM $\to$ Policies 에서 Create Policy 로 다시 Policy 를 생성할 수 있다. (이전의 inline 방식이 아니라 Managed 방식)
![AWS_AddPermission_to_Lambda](/Image/Server/AWS_AddPermission_to_Lambda.png)![[AWS_IAM_PolicesList.png]]

IAM  Roles 에서 ListFleets Lambda 의 Role 인 ListFleets-role-~ $\to$ Permissions $\to$ Permissions policies $\to$ Add permissions $\to$ Attach policy $\to$ ![[AWS_IAM_Rules_LambdaRole_AddPermission.png]] $\to$ Add permissions 클릭 $\to$ ![AWS_LambdaDashboard](/Image/Server/AWS_LambdaDashboard.png)$\to$ Lambda 에 새롭게 권한이 추가된 것을 볼 수 있다. 기존의 inline 으로 추가했던 것은 ListFleets 라는 Lambda 에만 국한 된 것이었다면 지금 추가한 GameLift_ListFleets 의 경우 다른 Lambda 들도 사용할 수 있는 Permission 이다.
이제 다시 ListFleets lambda로 돌아가서 test 를 진행하면 권한 문제가 해결 되었기 때문에 error 가 뜨지 않는 것을 확인할 수 있다.
