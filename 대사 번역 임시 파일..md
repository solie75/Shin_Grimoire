```diff
- So we've set our process parameters and we're almost ready to make the call to process ready.
+ 프로세스 파라미터를 설정했고 이제 ProcessReady를 호출할 준비가 거의 다 되었습니다.

- Back to the documentation. We see that that's the last thing we do is we call process ready on the Gamelift module.
+ 문서로 돌아가 봅시다. GameLift 모듈에서 ProcessReady를 호출하는 것이 마지막 단계라는 것을 알 수 있습니다.

- But there's one last piece before that. It says here the game server tells Gamelift where to find game session log files.
+ 하지만 그전에 마지막 한 가지가 남았습니다. 여기서 게임 서버가 GameLift에게 게임 세션 로그 파일을 어디서 찾을 수 있는지 알려준다고 되어 있습니다.

- At the end of a game session, Gamelift uploads everything in the specified location and stores it in the cloud for access later.
+ 게임 세션이 끝나면 GameLift는 지정된 위치의 모든 것을 업로드하고 나중에 액세스할 수 있도록 클라우드에 저장합니다.

- And this is useful because if we have our server running in the cloud on an EC2 instance, it'd be handy to access those logs at the end of a game instance.
+ 이것은 유용한데, 만약 EC2 인스턴스의 클라우드에서 서버를 실행 중이라면, 게임 인스턴스가 끝날 때 해당 로그에 액세스하는 것이 편리하기 때문입니다.

- And this is where we can tell Gamelift where to find the logs that it should save for us.
+ 여기가 바로 GameLift에게 우리를 위해 저장해야 할 로그를 어디서 찾을지 알려줄 수 있는 부분입니다.

- So it's giving us an example path to a log file, but our game isn't going to save this. Gamelift 426 test log.
+ 예제 로그 파일 경로를 보여주고 있지만, 우리 게임은 'Gamelift 426 test log'라는 이름으로 저장하지는 않을 겁니다.

- Typically, Unreal Engine saves a log file with the name of the project, in our case FS template, so we can use that as an example.
+ 일반적으로 언리얼 엔진은 프로젝트 이름으로 로그 파일을 저장하는데, 우리 경우에는 FSTemplate이므로 그것을 예시로 사용할 수 있습니다.

- But we can't just copy pasta our way to success, can we?
+ 하지만 그냥 복사 붙여넣기만 해서 성공할 수는 없겠죠?

- So we're going to create an array of f strings. We can call this log files. And we can take log files and add a string to it.
+ 그래서 FString 배열을 하나 만들 겁니다. 이걸 logFiles라고 부르죠. 그리고 logFiles에 문자열을 추가할 수 있습니다.

- We'll go ahead and use text as this is an F string that we'll make from a text literal.
+ 텍스트 리터럴로 만들 FString이므로 TEXT 매크로를 사용해서 진행하겠습니다.

- And we need to specify the path to the log file that will be saved.
+ 그리고 저장될 로그 파일의 경로를 지정해야 합니다.

- And if we take a look at our FF template project, you can always find the log files generated by an Unreal Engine project by going to the saved folder and going to logs.
+ FSTemplate 프로젝트를 살펴보면, Saved 폴더의 Logs로 이동하여 언리얼 엔진 프로젝트가 생성한 로그 파일을 언제든 찾을 수 있습니다.

- In fact, multiple logs are typically stored, but when the game server process runs, it's going to write log information to the FS template log because the project is called a template.
+ 사실 여러 로그가 저장되지만, 게임 서버 프로세스가 실행될 때 프로젝트 이름이 FSTemplate이므로 FSTemplate.log에 로그 정보를 기록할 것입니다.

- If your game project is called awesome MMO then it will be awesome MMO dot log. So that's going to be the path that we need is the path to the specific log file.
+ 만약 여러분의 게임 프로젝트 이름이 Awesome MMO라면 AwesomeMMO.log가 될 것입니다. 따라서 우리가 필요한 경로는 그 특정 로그 파일에 대한 경로입니다.

- So in the documentation they just happen to place this Gamelift 426 test, assuming that that's the name of the project, which isn't even really consistent with the rest of the documentation.
+ 문서에서는 프로젝트 이름을 가정하고 'Gamelift 426 test'라고 적어 놓았는데, 이건 문서의 다른 부분과도 별로 일관성이 없습니다.

- I don't even think they specify what the game project should be called, but we know ours is a template, so it's going to be a template for us.
+ 게임 프로젝트 이름을 뭐라고 해야 하는지 명시하지도 않은 것 같지만, 우리는 우리 프로젝트가 FSTemplate이라는 걸 아니까 우리에게는 FSTemplate이 될 겁니다.

- And we're going to go to the saved logs folder and get the log file that Unreal Engine will generate for us, which will be a template log and this specific case.
+ 그리고 Saved/Logs 폴더로 가서 언리얼 엔진이 생성해 줄 로그 파일을 가져올 건데, 이번 경우에는 FSTemplate.log가 되겠죠.

- So the path is going to be PHP template slash saved slash logs, slash FS template dot log.
+ 그래서 경로는 FSTemplate/Saved/Logs/FSTemplate.log가 될 것입니다.

- And now that we have this log files array we can set the process parameters log parameters with process parameters dot log parameters.
+ 이제 이 logFiles 배열이 있으니, ProcessParameters.logParameters를 설정할 수 있습니다.

- We can set that equal to this t array called log files. And of course we can put multiple paths in this log files variable as it's an array.
+ 이걸 logFiles라는 TArray와 같게 설정하면 됩니다. 물론 이건 배열이니까 logFiles 변수에 여러 경로를 넣을 수도 있습니다.

- And this will be stored on the cloud in Gamelift. And we can retrieve it later.
+ 그러면 이것이 GameLift 클라우드에 저장됩니다. 그리고 나중에 회수할 수 있죠.

- And there are different ways to do it. We can do it through the console, through API calls and so on.
+ 방법은 여러 가지가 있습니다. 콘솔을 통하거나, API 호출 등을 통해서 할 수 있습니다.

- And finally, the last thing we can do according to the documentation here is to call process. Ready to tell Gamelift it's ready to host game sessions.
+ 그리고 마지막으로, 여기 문서에 따르면 우리가 할 수 있는 마지막 작업은 ProcessReady를 호출하여 GameLift에게 게임 세션을 호스팅할 준비가 되었다고 알리는 것입니다.

- That's going to pass those process parameters over to Gamelift, so that now Gamelift can begin executing the callbacks bound to its delegates when those events happen.
+ 그러면 그 프로세스 파라미터들이 GameLift로 전달되어, 이제 GameLift는 해당 이벤트가 발생했을 때 델리게이트에 바인딩된 콜백들을 실행할 수 있게 됩니다.

- So we can copy a UI log and paste it down here and change it to say, calling process ready.
+ 그래서 UE_LOG를 복사해서 아래에 붙여넣고, "Calling ProcessReady"라고 출력되도록 변경하겠습니다.

- And then we can actually call process ready by getting our Gamelift SDK module and calling process ready and passing in our process parameters.
+ 그런 다음 GameLift SDK 모듈을 가져와서 ProcessReady를 호출하고 프로세스 파라미터를 전달함으로써 실제로 ProcessReady를 호출할 수 있습니다.

- And now we have all the code from the documentation. Of course we've made a couple of changes and improvements, but now our Unreal Engine game mode is set to connect to Gamelift.
+ 이제 문서에 있는 모든 코드를 작성했습니다. 물론 몇 가지 변경하고 개선한 점은 있지만, 이제 언리얼 엔진 게임 모드가 GameLift에 연결하도록 설정되었습니다.

- It's going to initialize Gamelift, set up the process parameters and call process ready. So that's it.
+ GameLift를 초기화하고, 프로세스 파라미터를 설정하고, ProcessReady를 호출할 것입니다. 자, 이게 다입니다.

- We now have a very basic outline for connecting our game to Gamelift. All that's left is to create an actual fleet and host our dedicated server, build on it and test this out
+ 이제 게임을 GameLift에 연결하기 위한 아주 기초적인 개요가 완성되었습니다. 남은 건 실제 플릿(Fleet)을 생성하고 데디케이티드 서버를 호스팅한 뒤, 빌드하고 테스트해보는 것입니다.

- and see if we can actually connect a Gamelift and start seeing some of these UI logs printed to our output log.
+ 그리고 실제로 GameLift에 연결할 수 있는지, 이 UE_LOG들이 출력 로그에 찍히는지 확인하는 것이죠.

- So that will be our next steps is to actually host our dedicated server on Gamelift.
+ 그래서 다음 단계는 실제로 GameLift에 데디케이티드 서버를 호스팅하는 것이 될 것입니다.
```