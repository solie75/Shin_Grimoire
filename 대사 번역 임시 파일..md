```diff
+ 이번 영상에서는 try catch 블록에 대해 이야기해 보겠습니다. 언리얼 엔진에서는 try catch를 사용하지 않기 때문에 여러분에게는 익숙하지 않을 수도 있습니다.
- In this video we're going to talk about try catch blocks, which is something you might not be used to in Unreal Engine as we don't use try catch in unreal.

+ 언리얼에서는 어설션(assertion)을 주로 사용하며, 이는 특정 조건이 충족되지 않을 때 프로그램 실행을 중단시킬 수 있게 해줍니다. 게임은 성능이 중요하기 때문에 그런 방식이 더 효율적인 경향이 있죠.
- In unreal, we opt for the use of assertions which allow us to halt the execution of our program when some condition is not met. Games tend to be more performant that way as performance is critical.

+ 람다(Lambda)에서 try catch 블록은 꽤 흔하게 사용됩니다. 이를 통해 명령 실행과 같은 작업을 시도(try)하고, 발생할 수 있는 모든 에러를 처리(handle)할 수 있기 때문입니다.
- Try catch blocks in lambdas are pretty common because they allow us to try something, such as executing a command and handling any errors that might arise.

+ 에러가 발생했을 때 명령을 재전송하는 등 우리가 원하는 모든 작업을 수행할 수 있습니다.
- And we can do anything we like. In the case of an error such as retry sending that command, and so on.

+ try catch 블록을 만드는 것은 아주 쉽습니다. 단순히 try 다음에 코드 블록을 사용하고, 그 블록 바로 뒤에 catch를 사용하면 됩니다.
- Now to create a try catch block, it's pretty easy. We simply use try followed by a block of code. And immediately after that block we catch.

+ catch는 에러를 입력으로 받습니다. 만약 에러가 발생하면(thrown), catch 블록이 이 error 객체에 저장된 에러를 잡아내며, 이를 통해 에러에 대응하는 로직을 무엇이든 구현할 수 있습니다.
- Now catch has an input for the error. If any error is thrown. The catch block will catch the error stored in this error object, and this allows us to have any sort of logic we like in response to the error.

+ 명령을 보내는 코드 라인들을 try 블록 안에 넣을 수 있습니다. 사실, 응답을 반환하는 코드를 포함시켜 조기에 반환(return early)할 수도 있습니다.
- So we can place these lines where we're sending the command in the try block. In fact, we can even return early by including the return response line of code.

+ 이 코드들을 잘라내어 여기 try 안에 넣습니다. 그리고 에러가 발생할 경우, 그 에러를 잡아낼(catch) 수 있습니다.
- So we can cut these and place them right here in the try. And in the case of an error, we can catch that error.

+ 그럼 에러가 발생했을 때 무엇을 할까요? 에러를 그대로 반환할 수도 있고, 상태 코드(status code)와 본문(body)을 직접 결정한 자바스크립트 객체를 반환할 수도 있습니다.
- So what do we do in the case of an error. Well we can return the error. We can also return a JavaScript object where we decide on the status code and the body.

+ 예를 들어, 상태 코드를 500으로 설정할 수 있습니다. 이는 서버가 요청을 수행하지 못하게 하는 예상치 못한 상황에 직면했을 때 보내는 일반적인 구조 신호입니다.
- For instance, we can say that status code is 500, which is basically a general distress signal that's sent out when the server encounters an unexpected condition that prevents it from fulfilling the request.

+ 본문(body)도 지정할 수 있으며, 이 본문에 에러에 대한 설명을 넣을 수 있습니다. 사실, Json.stringify를 사용하여 에러 객체를 문자열로 변환할 수도 있습니다. 참고로 return 문에는 세미콜론이 필요합니다.
- We can specify a body as well, and that body could be descriptive of the error. In fact, we could use Json.stringify and stringify the error object. Now the return statement does need a semicolon.

+ 이제 이것을 try catch 블록으로 감쌌습니다. 시도하려는 이 명령에서 에러가 발생하지 않으면 응답을 그대로 반환해야 합니다.
- So now we've wrapped this in a try catch block. And if we don't encounter any errors from this command we're attempting, then we should just return the response.

+ 이제 변경 사항을 배포하고, list fleets 테스트 이벤트를 실행하여 테스트해 볼 수 있습니다. 이 경우 응답에는 간단한 response 객체가 포함되어 있어 상태 코드 200과 다른 메타데이터, 그리고 fleet ID들이 함께 옵니다.
- Now we can deploy these changes, and we can run this test by testing our list fleets test event. And in this case our response contains the simple response object, so it has its own status code 200. Along with the other metadata as well as the fleet IDs.

+ 하지만 에러를 발생시키면 어떻게 보일까요? 우리는 이미 list fleets 권한이 없을 때 에러를 본 적이 있으므로, 에러를 일으키는 방법을 알고 있습니다.
- Right. But what does this look like if we cause an error? Well, we know how to cause an error. We've seen one before when we didn't have the permissions to list fleets.

+ 구성(Configuration)으로 돌아가서 이 람다 함수에 연결된 역할을 살펴볼 수 있습니다. IAM 콘솔에서 list fleets 정책을 선택하고 제거(remove)를 클릭합니다.
- In fact, we can go back to our configuration and take a look at the role attached to this lambda function... looking at the list fleet's role in the IAM console... we could select that policy and click on remove.

+ 정책 이름을 입력하여 확인하고 삭제하면, 더 이상 해당 권한을 갖지 않게 됩니다.
- This time it's asking me to type out the full name of the policy... I can delete that. And we no longer have that permission.

+ 이제 람다로 돌아가서 코드로 이동해 list fleets 이벤트를 다시 테스트해 봅니다. 상태는 여전히 '성공(succeeded)'으로 보입니다.
- Now, if I go back to Lambda and go back to code and attempt to test my list fleets event again. Now I can see that my status is still succeeded.

+ 하지만 응답은 에러가 문자열화된 버전입니다. 문자열화된 에러 객체 안에서 상태 코드가 실제로는 400인 것을 볼 수 있습니다.
- However, my response is the stringified version of the error, and we can see in the Stringified error object that the status code was actually 400.

+ 타입은 AccessDeniedException이며, 이 특정 에러가 무엇에 관한 것인지 설명하는 message 속성도 있습니다.
- The type is Accessdenied exception, and there's actually a message property explaining what this particular error is all about.

+ 람다 응답의 상태 코드는 일반적인 500 에러였지만, 본문에는 더 구체적인 정보(해당 에러의 상태 코드, AccessDeniedException 타입, 메시지)가 포함된 문자열화된 에러 객체가 들어있다는 점을 주목하세요.
- And just take note that the status code for the response of our lambda was 500. The general 500 error. But our body contains the Stringified error object itself with more specific information...

+ 이 모든 정보가 필요 없다면 반환할 내용을 지정할 수 있습니다. 예를 들어, 에러 메시지만 포함하고 싶다면 에러 메시지로 설정된 error 속성을 가진 객체를 생성하여 문자열화할 수 있습니다.
- If you don't want all of this information, you can specify what you return. For instance, we could stringify an object... where we may only want to include the error message so we can have an error property set to the error message.

+ 이것을 배포하고 테스트 이벤트를 다시 실행하면, 이제 응답에는 에러를 나타내는 500 상태 코드와 본문에 에러 메시지가 담긴 문자열화된 객체만 포함됩니다.
- If we deploy this. Then we can go ahead and run the test event again. And now our response only contains our status code of 500, indicating an error followed by the error message in our body...

+ 따라서 성공했을 때와 에러가 발생했을 때 응답 형식을 어떻게 할지 결정할 수 있습니다. try-catch는 기술적으로 코드에서 에러를 처리하는 가장 좋은 모범 사례입니다.
- So we can decide how to format the response both in the case of success and in the case of error. So trycatch is technically the best practice for handling errors in your code...

+ 특히 API 호출과 같은 비동기 작업을 다룰 때, 네트워크 오류나 예상치 못한 응답 같은 문제를 우아하게(gracefully) 관리하고 의미 있는 피드백을 제공하거나 수정 조치를 취할 수 있게 해줍니다.
- especially when dealing with asynchronous operations like calling these APIs. It allows you to gracefully manage any issues that might arise... and provide meaningful feedback, or take corrective action based on your needs for your code.

+ (중략: 이전에 삭제했던 정책을 다시 복구하는 과정) 인라인 정책은 특정 역할 내부에서만 사용되며 다른 역할에서는 접근할 수 없습니다. 하지만 정책(Policies) 섹션으로 가서 정책을 아예 새로 생성할 수도 있습니다.
- An inline policy is internal to this specific role and not accessible to other roles. But we can create a policy outright by going over to the policies section.

+ (중략: 새 정책 생성 및 연결 과정) 이제 정책이 복구되었으므로 list fleets로 돌아와서 코드로 이동해 테스트 이벤트를 다시 실행할 수 있습니다.
- Now that the policy is back, I can come back to list fleets, back to code, and I can go ahead and run my test event again.

+ 이제 더 이상 500 상태 코드가 뜨지 않고, fleet ID가 포함된 GameLift 클라이언트의 실제 응답을 받게 됩니다.
- And I see that I no longer get my status code of 500, but I get the actual response from the Gamelift client with the fleet IDs.

+ 이것이 바로 람다에서 발생하는 모든 에러를 원하는 방식으로 처리하기 위해 try-catch를 사용하는 방법입니다.
- So that's how we can use Trycatch in a Lambda in order to handle any errors that pop up in any way that we decide.
```