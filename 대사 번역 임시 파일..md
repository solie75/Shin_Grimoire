```diff
- It's time to learn about a new AWS service API gateway.
+ 이제 새로운 AWS 서비스인 API 게이트웨이(API Gateway)에 대해 알아볼 시간입니다.

- And before we get started, there's a link in the resources to information about the free tier for API gateway for the first 12 months.
+ 시작하기 전에, 처음 12개월 동안 제공되는 API 게이트웨이의 프리 티어에 대한 정보 링크가 리소스에 있으니 참고하세요.

- At the time of this recording, we get 1 million free rest API calls, as well as a million free HTTP and a million free messages or 750,000 connection minutes per month for that 12 month free tier period.
+ 이 영상을 녹화하는 시점 기준으로, 12개월 프리 티어 기간 동안 매월 100만 건의 무료 REST API 호출뿐만 아니라, 100만 건의 무료 HTTP 및 100만 건의 무료 메시지 또는 75만 분의 연결 시간을 제공받습니다.

- And you can also see the prices for these.
+ 그리고 이것들에 대한 가격도 확인할 수 있습니다.

- Once your free tier is up, you'll see the API calls per month.
+ 프리 티어 기간이 끝나면 월별 API 호출 요금을 보게 될 것입니다.

- The first 333 million is $3.50, the next 667 million costs 280.
+ 처음 3억 3천 3백만 건은 3.50달러이고, 그 다음 6억 6천 7백만 건은 2.80달러입니다.

- And the price goes down after that.
+ 그 이후로는 가격이 더 내려갑니다.

- So as you can see, you can use a tremendous amount of API calls for a very small price.
+ 보시다시피, 매우 적은 비용으로 엄청난 양의 API 호출을 사용할 수 있습니다.

- And these prices are really only significant when you have a very large player base or user base for your game or app.
+ 그리고 이러한 비용은 여러분의 게임이나 앱에 매우 큰 규모의 플레이어 기반이나 사용자 기반이 있을 때에만 실제로 유의미해집니다.

- So that's useful information to know.
+ 그러니 알아두면 유용한 정보입니다.

- So let's go to the API gateway console.
+ 그럼 API 게이트웨이 콘솔로 가보겠습니다.

- We can always search for API gateway and go straight to the API gateway console.
+ 언제든지 API 게이트웨이를 검색해서 바로 콘솔로 이동할 수 있습니다.

- Here's what it looks like.
+ 콘솔 화면은 이렇게 생겼습니다.

- And we can choose an API type for the API that we would like to make.
+ 그리고 만들고 싶은 API의 유형을 선택할 수 있습니다.

- Now, as mentioned in the last video, http API is cheaper, but it doesn't have as many features as the rest API.
+ 지난 영상에서 언급했듯이 HTTP API가 더 저렴하지만, REST API만큼 많은 기능을 가지고 있지는 않습니다.

- And since the prices are so similar, Rest API gives us more benefits that we'd like to use.
+ 그리고 가격 차이가 크지 않기 때문에, 우리가 사용하고 싶은 더 많은 이점을 제공하는 REST API를 선택하는 것이 좋습니다.

- And WebSocket APIs are not necessary for our use case, but they are useful if you need a two way communication that you open between client and server.
+ 그리고 WebSocket API는 현재 우리의 사용 사례에는 필요하지 않지만, 클라이언트와 서버 간에 열린 양방향 통신이 필요할 때는 유용합니다.

- But we're going to make a rest API.
+ 하지만 우리는 REST API를 만들 것입니다.

- Now there are two options.
+ 여기에는 두 가지 옵션이 있습니다.

- One is a private Rest API, which restricts the API calls to internal messages within your VPC, your virtual private cloud?
+ 하나는 프라이빗(Private) REST API인데, 이는 API 호출을 여러분의 VPC, 즉 가상 프라이빗 클라우드(Virtual Private Cloud) 내부의 메시지로 제한합니다.

- Now, as mentioned in previous videos, each region on AWS has a VPC, and that's where all of your services are hosted.
+ 이전 영상들에서 언급했듯이 AWS의 각 리전에는 VPC가 있으며, 그곳에 여러분의 모든 서비스가 호스팅됩니다.

- But if we don't choose private, then we can send rest API calls into and out of our VPC, such as from an Unreal Engine project running on a client.
+ 하지만 프라이빗을 선택하지 않으면, 클라이언트에서 실행되는 언리얼 엔진 프로젝트에서처럼 VPC 안팎으로 REST API 호출을 보낼 수 있습니다.

- So we're going to make a regular Rest API.
+ 그래서 우리는 일반적인 REST API를 만들 것입니다.

- And there's an option to import a rest API.
+ 그리고 REST API를 가져오기(Import) 할 수 있는 옵션도 있습니다.

- But we are going to build one here in the console.
+ 하지만 우리는 여기 콘솔에서 직접 하나를 구축할 것입니다.

- So we're going to click on build.
+ 그러니 '구축(Build)'을 클릭하겠습니다.

- And we can start from a number of options.
+ 여러 옵션 중에서 시작할 수 있습니다.

- But we're going to create a fresh new API.
+ 하지만 우리는 완전히 새로운 API를 생성할 것입니다.

- Now this API is going to be for operations that result in cloud SDK calls, such as the Lambda we created in the last section for listing fleets.
+ 이 API는 지난 섹션에서 플릿 목록을 조회하기 위해 만든 람다(Lambda)처럼 클라우드 SDK 호출을 수행하는 작업들을 위한 것입니다.

- So rather than a terrible name like my rest API, we're going to give this a more meaningful name later.
+ 그래서 '내 REST API(my rest API)' 같은 형편없는 이름보다는 나중에 더 의미 있는 이름을 지어주려고 합니다.

- We'll have some API methods for user related stuff, such as creating a new user and a user pool.
+ 나중에 새로운 사용자 생성이나 사용자 풀(User Pool) 같은 사용자 관련 작업을 위한 API 메서드들도 갖게 될 것입니다.

- And I'd like to distinguish between a Rest API that has capabilities for doing things related to users versus doing things related to gameplay and gamelift game sessions, so we can keep our game related methods in this API.
+ 그리고 사용자 관련 작업을 수행하는 기능을 가진 REST API와 게임 플레이 및 GameLift 게임 세션 관련 작업을 수행하는 것을 구별하고 싶으므로, 게임 관련 메서드들은 이 API에 두도록 하겠습니다.

- So I'm going to call this API game sessions.
+ 그래서 저는 이 API의 이름을 '게임 세션(game sessions)'이라고 짓겠습니다.

- And all of our API calls related to game sessions will be here.
+ 그리고 게임 세션과 관련된 모든 API 호출은 이곳에 있게 될 것입니다.

- We can even give it a description.
+ 설명도 추가할 수 있습니다.

- This API is related to game sessions and associated functionality.
+ '이 API는 게임 세션 및 관련 기능에 관한 것입니다.'라고 적겠습니다.

- Now once we create some endpoints for our API, these are going to be deployed in specific regions.
+ 이제 우리 API를 위한 엔드포인트를 몇 개 만들면, 이것들은 특정 리전에 배포될 것입니다.

- So our API endpoint type is going to be regional.
+ 그래서 우리 API 엔드포인트 유형은 '리전(Regional)'이 될 것입니다.

- You could make it private for use within your VPC.
+ VPC 내부에서 사용하기 위해 프라이빗으로 만들 수도 있습니다.

- And it says edge optimized API route requests to the nearest CloudFront point of presence.
+ 그리고 '엣지 최적화(Edge optimized)'라고 되어 있는데, 이건 가장 가까운 CloudFront POP(Point of Presence)로 API 요청을 라우팅합니다.

- That's if you're using a service called CloudFront.
+ 이건 CloudFront라는 서비스를 사용할 때 해당됩니다.

- For us regional is fine.
+ 우리에게는 리전(Regional)이면 충분합니다.

- So let's create the API.
+ 그럼 API를 생성해 봅시다.

- So we've successfully created a new API called Game Sessions.
+ 이렇게 해서 'Game Sessions'라는 새로운 API를 성공적으로 생성했습니다.

- It has a resource ID and in order to create API endpoints, we need to create a resource.
+ 리소스 ID를 가지고 있는데, API 엔드포인트를 만들기 위해서는 리소스를 생성해야 합니다.

- And a resource will have its own name and it can get its own methods.
+ 리소스는 고유한 이름을 가지며, 자신만의 메서드를 가질 수 있습니다.

- And those methods can be linked up with lambda functions.
+ 그리고 그 메서드들은 람다 함수와 연결될 수 있습니다.

- So to create a resource we simply click on Create Resource.
+ 리소스를 생성하려면 간단히 '리소스 생성(Create Resource)'을 클릭하면 됩니다.

- And we can organize these resources within a structure similar to file directories.
+ 그리고 우리는 이 리소스들을 파일 디렉터리와 유사한 구조로 정리할 수 있습니다.

- We just have a root thus far.
+ 지금은 루트(Root)만 있는 상태입니다.

- And we'll give this resource a name.
+ 이 리소스에 이름을 지어줍시다.

- We can have dashes in our name.
+ 이름에 대시(-)를 넣을 수 있습니다.

- And just to see how all of this works, we're going to create a resource that will have an endpoint to trigger the lambda that we created, which just to remind ourselves, we're going to go back to the lambda console.
+ 이 모든 것이 어떻게 작동하는지 확인하기 위해, 우리가 만들었던 람다를 트리거할 엔드포인트를 가진 리소스를 하나 만들 것입니다. 람다를 다시 상기하기 위해 람다 콘솔로 돌아가 보겠습니다.

- I'm going to open it in a new tab here.
+ 여기서 새 탭으로 열어보겠습니다.

- And in this tab we have the list fleets Lambda function.
+ 이 탭에는 'list fleets' 람다 함수가 있습니다.

- Now I typically like to call my resources something similar to the lambda functions that are going to trigger.
+ 저는 보통 리소스 이름을 트리거할 람다 함수와 비슷하게 짓는 것을 좋아합니다.

- So I'm going to call this resource list fleets and create the resource.
+ 그래서 이 리소스 이름을 'list fleets'라고 짓고 생성하겠습니다.

- Once we've created the resource under resources, we have list fleets right here under the slash.
+ 리소스를 생성하고 나면 리소스 탭 아래 슬래시(/) 밑에 'list fleets'가 있는 것을 볼 수 있습니다.

- That's the root of our resources.
+ 그 슬래시가 바로 우리 리소스의 루트입니다.

- And list fleets has no methods.
+ 그리고 'list fleets'에는 아직 메서드가 없습니다.

- And we can have one or more methods per resource.
+ 리소스당 하나 이상의 메서드를 가질 수 있습니다.

- And that's going to result in creating an API gateway endpoint with its own URL.
+ 그렇게 하면 고유한 URL을 가진 API 게이트웨이 엔드포인트가 생성됩니다.

- And we can access that URL via HTTP requests.
+ 그리고 우리는 HTTP 요청을 통해 그 URL에 접근할 수 있습니다.

- So to create a method it's pretty easy.
+ 메서드를 생성하는 것은 꽤 쉽습니다.

- We select the list fleet's resource, and under methods we can click create method and we choose a method type.
+ 'list fleets' 리소스를 선택하고 메서드 탭 아래에서 '메서드 생성(Create method)'을 클릭한 뒤 메서드 유형을 선택합니다.

- Now the dropdown shows these HTTP request method types.
+ 드롭다운 메뉴에 HTTP 요청 메서드 유형들이 나옵니다.

- There are more here than I mentioned in the previous video, but the main ones we really need to concern ourselves with are usually get, post, put and delete.
+ 지난 영상에서 언급한 것보다 더 많은 유형이 있지만, 우리가 주로 신경 써야 할 핵심적인 것들은 보통 GET, POST, PUT, DELETE입니다.

- I leave it as an optional exercise for you to research what the others are typically used for now list fleets simply gets the fleet information from Gamelift.
+ 나머지가 주로 어디에 쓰이는지 알아보는 것은 여러분의 자율 과제로 남겨두겠습니다. 지금 'list fleets'는 단순히 GameLift에서 플릿 정보를 가져오기만 하면 됩니다.

- So for this we're going to use a get method type.
+ 그래서 여기에는 GET 메서드 유형을 사용할 것입니다.

- And the integration type allows us to do different things.
+ 그리고 통합 유형(Integration type)을 통해 다양한 작업을 할 수 있습니다.

- In response to making the request to our endpoint, we want a lambda function integrated.
+ 엔드포인트에 요청을 보냈을 때 그에 대한 응답으로 람다 함수가 통합되어 작동하기를 원합니다.

- And when we choose lambda function we can choose a function by region.
+ 람다 함수를 선택하면 리전별로 함수를 고를 수 있습니다.

- Remember lambdas can exist in different regions.
+ 람다는 서로 다른 리전에 존재할 수 있다는 것을 기억하세요.

- Mine exists in US East two.
+ 제 것은 US East 2에 있습니다.

- And if I click on this, we'll see the one and only lambda function that exists in US two list fleets.
+ 이걸 클릭하면 US East 2에 있는 유일한 람다 함수인 'list fleets'가 보일 것입니다.

- As we create more, we'll see more options here.
+ 람다를 더 많이 만들면, 여기에 더 많은 옵션이 나타날 것입니다.

- So I'm going to choose list fleets and it just gives me the Arn for it.
+ 그래서 저는 'list fleets'를 선택할 것이고, 그러면 해당 함수의 ARN(Amazon Resource Name)이 표시됩니다.

- That's how we identify that lambda function.
+ 그게 바로 그 람다 함수를 식별하는 방법입니다.

- Lambda proxy integration is a feature of API gateway that simplifies the process of connecting your Rest API to a Lambda function.
+ 람다 프록시 통합(Lambda proxy integration)은 REST API를 람다 함수에 연결하는 과정을 단순화해 주는 API 게이트웨이의 기능입니다.

- It has a more simplified integration with a Lambda proxy integration.
+ 람다 프록시 통합을 사용하면 통합이 더 간소화됩니다.

- The API gateway passes the entire A request to the lambda function as an event object directly.
+ API 게이트웨이는 전체 요청을 이벤트 객체로 람다 함수에 직접 전달합니다.

- The lambda function then processes the request and returns a response directly.
+ 그러면 람다 함수가 요청을 처리하고 응답을 직접 반환합니다.

- But we want to go through the API because we can implement security measures through API gateway, and we're going to be doing that later.
+ 하지만 우리는 API 게이트웨이를 통해 보안 조치를 구현할 수 있기 때문에 API를 거쳐 가고 싶으며, 나중에 그렇게 할 것입니다.

- Now when we choose a Lambda function, the node says grant API gateway permission to invoke your Lambda function to turn off, update the function's resource policy yourself, or provide an invoke role the API gateway uses to invoke your function.
+ 람다 함수를 선택하면, API 게이트웨이에 람다 함수를 호출할 수 있는 권한을 부여한다는 안내가 나옵니다. 이를 끄려면 함수의 리소스 정책을 직접 업데이트하거나 API 게이트웨이가 함수를 호출할 때 사용할 호출 역할(Invoke role)을 제공해야 합니다.

- So we'll automatically have permissions, and we would have to go and update the Lambda functions resource policy to disable that.
+ 따라서 권한은 자동으로 갖게 되며, 이를 비활성화하려면 람다 함수의 리소스 정책을 직접 업데이트해야 합니다.

- We don't want to do that.
+ 우리는 그렇게 하고 싶지 않습니다.

- Now generally these API call operations are very quick.
+ 일반적으로 이러한 API 호출 작업은 매우 빠릅니다.

- But if things take longer than expected they can timeout.
+ 하지만 예상보다 오래 걸리면 타임아웃(Timeout)이 발생할 수 있습니다.

- And the timeout duration can be changed here.
+ 타임아웃 지속 시간은 여기서 변경할 수 있습니다.

- But we're going to leave it at defaults.
+ 하지만 우리는 기본값으로 두겠습니다.

- Now for method request settings we can set up authorization.
+ 이제 메서드 요청 설정에서 인증(Authorization)을 설정할 수 있습니다.

- We'll learn how to do that later.
+ 그건 나중에 배우게 될 것입니다.

- We can have URL query string parameters.
+ URL 쿼리 문자열 파라미터를 가질 수도 있습니다.

- We don't need any for this and we can have request headers.
+ 이번에는 필요하지 않지만, 요청 헤더(Request headers)를 가질 수도 있습니다.

- We can specify that this URL requires a header in its HTTP request.
+ 이 URL로 보내는 HTTP 요청에 헤더가 필요하다고 지정할 수 있습니다.

- And this is where we can define structure and content of the data that the API method expects.
+ 그리고 여기서 API 메서드가 기대하는 데이터의 구조와 내용을 정의할 수 있습니다.

- This particular method is a Get method.
+ 이 메서드는 GET 메서드입니다.

- It doesn't expect any data, so let's create the method.
+ 어떤 데이터도 기대하지 않으므로, 메서드를 생성해 봅시다.

- Once we've done that under our resources list, fleets now has its own dropdown.
+ 생성을 완료하면 리소스 목록의 'list fleets' 아래에 드롭다운 메뉴가 생깁니다.
=============================
- We can expand and collapse and it shows the method we created, specifically a Get method.
+ 펼치거나 접을 수 있으며, 우리가 만든 메서드, 구체적으로는 GET 메서드를 보여줍니다.

- And with the get method selected we can see the details.
+ GET 메서드를 선택하면 세부 정보를 볼 수 있습니다.

- We can see the method request and edit properties of that.
+ 메서드 요청을 보고 속성을 편집할 수 있습니다.

- This is where we would add authorization requirements and so on.
+ 여기가 바로 인증 요구 사항 등을 추가하는 곳입니다.

- I'm going to cancel that.
+ 저는 취소하겠습니다.

- We can see the integration request integration is what is this method integrated with.
+ 통합 요청(Integration request)을 볼 수 있는데, 이건 이 메서드가 무엇과 통합되어 있는지를 나타냅니다.

- It's integrated with a lambda.
+ 람다와 통합되어 있죠.

- And we can scroll down and see the other options.
+ 아래로 스크롤 해서 다른 옵션들을 볼 수 있습니다.

- So if you need to change its setup, you can do so even after you've created the Get method.
+ 그러니 설정 변경이 필요하다면 GET 메서드를 생성한 후에도 변경할 수 있습니다.

- So our request is integrated with Lambda.
+ 그래서 우리의 요청은 람다와 통합되었습니다.

- We also have integration response settings.
+ 통합 응답(Integration response) 설정도 있습니다.

- Our method response has settings.
+ 메서드 응답에도 설정이 있습니다.

- We haven't configured anything special here.
+ 여기서는 특별히 설정한 것이 없습니다.

- Notice the content type of the response is JSON.
+ 응답의 콘텐츠 유형(Content type)이 JSON이라는 점에 주목하세요.

- And the last tab is test, which is a pretty useful feature of these APIs.
+ 마지막 탭은 테스트(Test)인데, 이는 API의 아주 유용한 기능입니다.

- We can actually test our API from right here within the API gateway console.
+ API 게이트웨이 콘솔 내에서 바로 우리 API를 테스트해 볼 수 있습니다.

- We can put in strings for our query.
+ 쿼리에 문자열을 넣을 수 있습니다.

- We can put in headers and optionally a certificate if that's required.
+ 헤더를 넣을 수 있고, 필요하다면 인증서를 선택적으로 넣을 수도 있습니다.

- And we can simply click on test.
+ 그리고 그냥 '테스트'를 클릭하면 됩니다.

- And this will actually run our API and show us the results.
+ 그러면 실제로 API가 실행되고 결과를 보여줍니다.

- Notice that we actually executed this Get method.
+ 우리가 실제로 이 GET 메서드를 실행했다는 것을 알 수 있습니다.

- And here in the response take a look.
+ 그리고 여기 응답을 보세요.

- Here's the result.
+ 결과가 있습니다.

- And it contains the fleet IDs showing the fleet ID of our anywhere fleet.
+ 플릿 ID가 포함되어 있는데, 우리의 'Anywhere fleet' ID를 보여줍니다.

- It even shows the headers that are in the response.
+ 응답에 포함된 헤더까지 보여줍니다.

- The header contains a content type indicating that this is JSON formatted and a trace ID for Amazon.
+ 헤더에는 이것이 JSON 형식임을 나타내는 콘텐츠 유형과 Amazon용 트레이스 ID(Trace ID)가 포함되어 있습니다.

- And here in the test console we have logs as well.
+ 그리고 여기 테스트 콘솔에는 로그도 있습니다.

- So this is extremely useful.
+ 정말 유용하죠.

- And if we search for the CloudWatch service and we simply open this in a new tab and go to our log groups and find the log group for our list Fleets Lambda, we'll see that there's a new log stream.
+ CloudWatch 서비스를 검색해서 새 탭으로 열고 로그 그룹으로 가서 'list Fleets' 람다용 로그 그룹을 찾아보면, 새로운 로그 스트림이 있는 것을 볼 수 있습니다.

- If we click on that, we'll see that we've actually run the list fleets Lambda function.
+ 그걸 클릭하면 우리가 실제로 'list fleets' 람다 함수를 실행했다는 것을 확인할 수 있습니다.

- So testing actually does execute that lambda function from directly here inside of API gateway.
+ 즉, 테스트를 하면 여기 API 게이트웨이 내부에서 직접 해당 람다 함수가 실행되는 것입니다.

- This is really nice because it just gives us an opportunity to test the API gateway to make sure that it works before we go and deploy it and try to test it elsewhere, such as from our Unreal Engine code.
+ 이건 정말 좋은 기능인데, 나중에 배포해서 언리얼 엔진 코드 같은 다른 곳에서 테스트해 보기 전에 API 게이트웨이가 제대로 작동하는지 미리 확인해 볼 수 있는 기회를 주기 때문입니다.

- Now, speaking of testing it from Unreal Engine code, that is not possible yet.
+ 언리얼 엔진 코드에서 테스트하는 이야기가 나와서 말인데, 그건 아직 불가능합니다.

- And the reason is because we have not deployed our API.
+ 그 이유는 우리가 아직 API를 배포(Deploy)하지 않았기 때문입니다.

- Every time we change our API by adding methods and resources, the API has stages of deployment which we haven't set up yet.
+ 메서드나 리소스를 추가해서 API를 변경할 때마다, API에는 배포 단계(Stages)라는 것이 있는데 우리는 아직 이걸 설정하지 않았습니다.

- And those deployment stages are what determine what happens when someone attempts to call these API methods.
+ 그리고 그 배포 단계들이 누군가 이 API 메서드를 호출하려고 할 때 어떤 일이 일어날지를 결정합니다.

- Now deploying it is quite easy.
+ 배포하는 것은 꽤 쉽습니다.

- We simply click on deploy API up here at the top where we choose a stage.
+ 위쪽에 있는 'API 배포(Deploy API)'를 클릭하고 단계를 선택하면 됩니다.

- Now, if we don't have a stage, we can create a new stage by choosing new stage and giving it a stage name.
+ 만약 단계가 없다면, '새 단계(New stage)'를 선택하고 단계 이름을 지어주어 새로 만들 수 있습니다.

- And the stage name is how we identify which stage we're wishing to use.
+ 단계 이름은 우리가 어떤 단계를 사용하고 싶은지 식별하는 방법입니다.

- And if we have significant different changes to these versions of our API, we can call them different stages.
+ 그리고 API 버전에 따라 상당히 다른 변경 사항이 있다면, 그것들을 서로 다른 단계라고 부를 수 있습니다.

- For now, I'm just going to call it stage underscore one.
+ 지금은 그냥 'stage_1'이라고 부르겠습니다.

- We can have an optional deployment description if you have important details.
+ 중요한 세부 사항이 있다면 선택적으로 배포 설명을 추가할 수 있습니다.

- As these applications scale, these stages will have important information in their deployment descriptions.
+ 애플리케이션 규모가 커지면, 이 단계들의 배포 설명에 중요한 정보가 담기게 될 것입니다.

- So we're creating a new stage called stage one.
+ 그래서 우리는 'stage 1'이라는 새로운 단계를 생성하고 있습니다.

- We're going to click deploy, and we now know that our API has been deployed.
+ '배포(Deploy)'를 클릭하면, 이제 우리 API가 배포되었다는 것을 알 수 있습니다.

- This means it's now live, which results in an invoke URL.
+ 이건 이제 라이브 상태가 되었다는 뜻이며, 그 결과로 호출 URL(Invoke URL)이 생성됩니다.

- Here we have an invoke URL for our API.
+ 여기에 우리 API를 위한 호출 URL이 있습니다.

- This is the invoke URL to access the API, but to call specific methods, we need the invoke URL for the method itself, and we can see those from the stages panel where in stages now no longer resources because when we deploy we're taken to the stages panel.
+ 이것은 API에 접근하기 위한 호출 URL이지만, 특정 메서드를 호출하려면 메서드 자체에 대한 호출 URL이 필요합니다. 이는 '단계(Stages)' 패널에서 확인할 수 있는데, 배포를 하면 리소스 패널에서 단계 패널로 이동하기 때문입니다.

- If we expand the stages to see our resources, we can find our get method and see its invoke URL, which is the same as our stages URL with a slash followed by the resource name.
+ 단계를 펼쳐서 리소스를 보면, 우리의 GET 메서드를 찾을 수 있고 그 호출 URL을 볼 수 있습니다. 이는 단계 URL 뒤에 슬래시와 리소스 이름이 붙은 형태입니다.

- So if we send an HTTP request with this URL, it is going to attempt to invoke this get method.
+ 따라서 이 URL로 HTTP 요청을 보내면, 이 GET 메서드 호출을 시도하게 될 것입니다.

- So if you're trying to find your invoke URL and you can't find it because you're over here in resources and you click on your get method and you're looking for it here.
+ 만약 호출 URL을 찾으려고 하는데, 리소스 탭에서 GET 메서드를 클릭하고 거기서 찾으려고 한다면 찾을 수 없을 것입니다.

- You can't find it because that method URL is associated with the current stage.
+ 왜냐하면 그 메서드 URL은 현재 단계(Stage)와 연결되어 있기 때문입니다.

- And we have to go to stages in order to find that invoke URL.
+ 그래서 그 호출 URL을 찾으려면 단계 탭으로 가야 합니다.

- And we have to find the specific method to get that method specific invoke URL.
+ 그리고 해당 메서드 고유의 호출 URL을 얻으려면 특정 메서드를 찾아야 합니다.

- So it will be using this URL to invoke this API gateway method.
+ 그래서 이 API 게이트웨이 메서드를 호출하기 위해 이 URL을 사용할 것입니다.

- So now we just need to know how to create an HTTP request.
+ 이제 우리는 HTTP 요청을 만드는 방법만 알면 됩니다.

- Send it to this invoke URL and receive the response.
+ 이 호출 URL로 요청을 보내고 응답을 받는 것이죠.

- And that's one of our next steps that will be in the videos to come.
+ 그건 앞으로 나올 영상들에서 다룰 다음 단계 중 하나입니다.

- Excellent job.
+ 아주 잘하셨습니다.

- We now have an API gateway with our own Get method for the resource list fleets.
+ 이제 우리는 'list fleets' 리소스에 대한 고유한 GET 메서드를 가진 API 게이트웨이를 갖게 되었습니다.

- And remember, List Fleets is a resource that can have multiple methods.
+ 그리고 'List Fleets'는 여러 메서드를 가질 수 있는 리소스라는 점을 기억하세요.

- We can create a post method for instance, and that would have the same invoke URL.
+ 예를 들어 POST 메서드를 만들 수도 있는데, 그건 동일한 호출 URL을 갖게 될 것입니다.

- The only difference is the HTTP request would specify a different method type.
+ 유일한 차이점은 HTTP 요청이 다른 메서드 유형을 지정한다는 것입니다.

- It would specify the type for that particular method, whether it's post or delete or whatever it is.
+ POST든 DELETE든 그 특정 메서드에 맞는 유형을 지정하게 될 것입니다.
```