가상함수는 런타임 다형성을 구현하기 위해 사용합니다. 이는 부모클래스의 포인터가 자식 객체를 가리키고 있을 땨, 컴파일 타임이 아닌 실제 런타임 객체 아팁에 맞춰서 재정의 된 함수를 호출하도록 보장합니다.
내부적으로는 V-Table과 vptr을 통해 함수 주소를 동적으로 바인딩하는 방식으로 동작합니다.

다만 테이블 참조의 과정이 미세한 오버헤드 이기 때문에 자주 호출되는 가벼운 연산들에는 주의해야 합니다.

컴파일러는 각 클래스마다 고유의 V-Table 을 만듭니다.
컴파일러는 우선 부모 클래스의 V-Table 을 만든고 후에 자식 클래스의 V-Table 을 만듭니다. 자식 클래스의 V-Table 을 만들 때 부모클래스의 V-Table 을 복사하여 생성하며 이때 Virtaul Override 한 자식 클래스의 가상함수는 복사한 V-Table 의 오버라이드 대상이 되는 부모 클래스의 가상함수 자리를 덮어쓰기 합니다.

예를 들어 부모클래스의 V-Table 0번 index 에는 부모의 특정 함수 AFuction 가 있다고 가정해보겠습니다. (v-table\[0], 0x1000(&Parent::AFunction()))
자식 클래스는 부모의 V-Table 구조를 그대로 복사하여 생성됩니다. 그리고 V-Table 의 0 번째 index를 비우고 해당 index 에 AFunction 을 오버라이딩한 함수를 저장하는 겁니다.

부모 클래스 타입에 자식 객체를 new 로 생성하여 대입하면 해당 메모리에는 실제 자식 객체가 생성됩니다. 이 객체가 들고 있는 가상함수 포인터는 부모타입 클래스의 가상함수가 아니라 자식 타입 클래스의 가상 함수를 가리키게 됩니다. 생성된 객체로 함수에 접근할 때에는 겉보기에는 부모 타입 객체와 같이 보이지만 실제로 컴파일러가 해당 함수 포인터를 추적할면 자식 클래스의 V-Table 에 접근하게 되고 거기에 적힌 자식 함수를 호출하게 되는 것입니다.
