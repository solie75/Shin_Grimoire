lambda 를 생성하고 lambda 의 입력 및 출력 데이터가 JSON 형식인 것을 알 수 있었다. 하지만 이것은 콘솔에서 테스트 한 것으로 지금 부터 언리얼 엔진 c++ 코드 내부에서 해당 Lambda 를 실행시켜보자.

이를 위해서는 [[HTTP|HTTP]] 를 이용해야 한다.

언리얼 엔진 c++ 코드 내부에서 HTTP 요청을 보낼 수 있다. 이때 메서드를 지정하여 요청을 지정된 URL 로 전송한다.

Lambda는 고유한 HTTP URL 을 가질 수 있어서 직접 HTTP 요청을 보낼 수 있지만, AWS API Gateway 서비스를 이용하여 HTTP 요청 보내는 것이 더 좋은 방법이다.

- API Gateway

커스텀 API ( Application Programming Interfaces) 를 만들 수 있다. 다음 3가지의 방식 중 한가지를 고른다.
- REST APIs (Representational State Transfer)
	- HTTP 메서드를 사용하여 리소스를 생성, 읽기, 업데이트, 삭제하는데 사용된다.
	- 상태를 저장하지 않는다.
	- 클라이언트 별 API 키, 스로틀링(throttling), 요청 유효성 검사, 프라이빗 API 엔드 포인트 (HTTP API 에는 없음.)
- HTTP APIs
	- REST API 과 같이 RESTful 하지만 기능이 더 적기 때문에 비용이 적게 발행한다.
- WebSocket API
	- 전이중 통신 허용 (Full duplex communication) (two-way interaction)
	- Dedicated Server 빌드에 설정한 AWS 서버 SDK 는 내부적으로 GameLift 에 연결하기 위해 WevSocket 을 사용한다. 이를 위해서 WebSocketURLEndpoint 를 얻었던 것.

- Create API
	- REST_APIs 로 고유한 엔드포인트 URL 을 가진 하나 이상의 메서드가 포함된 Resource 를 만들 수 있다.
	- 해당 resource 의 method 를 호출하면 HTTP요청 데이터를 lambda로 전달하면서 lambda 의 실행을 트리거할 수 있다.

 - API Gateway 이점.
	 - 중앙 집중식 관리 (Centralized Management)
		 - 모든 API 에 대한 하나의 진입점을 제공하여 관리와 모니터링, 업데이트에 용이하다.
		 - API Gateway 가 없다면 게임 클라이언트가 '로그인 서버 주소', '매칭 서버 주소', '상점 서버 주소' 를 다 따로 알고 있어야 하며 주소가 바뀌면 게임도 업데이트 해야한다. 하지만 API Gateway 가 있다면 클라이언트느 하나의 Gateway URL 만 알면 된다.
	- Security
		- throttling(속도제한), authentication, authorization 등과 같은 내장 보안 기능을 제공하여 오직 유효한 요청만 람다 함수에 도달하도록 보장한다.
			- Throttling : ddos 같은 공격에도 미리 설정해 놓은 제한 때문에 정해진 요청만 허용하고 나머지는 차단한다.
			- Authentication : 해당 요청을 보낸 사용자가 누구인지를 확인한다.
			- Authorization : 해당 요청을 보낸 사용자의 권한을 확인한다.
	- Scalability
		- 대량의 요청을 처리할 수 있으며, 수요에 맞춰 자동으로 규모를 확장하기 때문에 사용자가 직접 인프라를 관리할 필요가 없다.
		- 게임 좁속자가 적을 때나 많을 때 AWS 가 알아서 처리 용량을 조정한다.
	- Versioning
		- API의 다양한 버전을 관리할 수 있어서, 기존 사용자에게 지장을 주지 않고 새로운 기능이나 업데이트를 배포할 수 있다.
		- 여러 버전을 동시에 열어두는 것이 가능하다.
		- 아직 업데이트 안 한 유저는 그 이전 버전으로, 업데이트 한 유저는 그 이후 버전으로 자연스럽게 안내하여 서비스 점검 없이 자연스럽게 세대 교체가 가능하다
	- Monitoring and Logging.
		- 상세한 모니터링 및 로깅 기능을 제공하여 사용량, 성능, 오류를 추적할 수 있게 도와준다.
	- Caching
		- 응답을 캐싱할 수 있어, 람다 함수의 부하를 줄이고 사용자의 응답 시간을 개선해 준다.

- API Gateway 사용
![APIGatewayExamplePlan](/Image/Server/AWS_APIGatewayExamplePlan.png)
1. Widget
	1. 버튼 위젯을 클릭하면 그에 대한 코드가 실행되고, 해당 코드는 결과적으로 엔드 포인트로 HTTP 요청을 보내도록 한다.
	2. 여기에서 엔드 포인트는 하나 이상의 HTTP 메서드(Get, Post 등)와 연결될 것이고, 이 메서드는 HTTP 요청 데이터를 자신의 이벤트 입력 개체로 받아들이는 람다 함수들과 연결된다.
2. HTTP Request Manager
	1. 위젯과 AWS 사이의 중개 역할을 하는 별도의 클래스를 만든다.
	2. 위젯의 명령을 받으면 메서드, URL, Header 등의 HTTP Request 를 API Gateway 로 보낸다.
3. API Gateway
	1. HTTP Request 를 검사한 뒤 람다를 trigger 한다.
4. HTTP Response
	1. 람다의 결과 값을 HTTP Request Manager 가 받는다. Manager 는 결과를 Parsing 하여 위젯에게 알린다.

##### API Gateway

- [API Gateway 요금](https://aws.amazon.com/ko/api-gateway/pricing/)

- API Gateway 생성
	- AWS $\to$ API Gateway $\to$ Create API $\to$  REST API (REST API Private 선택지도 있지만 이는 API 호출을 VPC(Virtual Private Cloud; 가상 프라이빗 클라우드) 내부의 메시지로 제한한다. 즉 REST API Private 은 AWS 내부에 있는 Lambda 나 EC2 서버끼리는 해당 API를 주고 받을 수 있다. 하지만 유저 언리얼 클라이언트와는 API 를 연결할 수 없다. 반면에 REST API 는 유저 언리얼 클라이언트 와 API 의 연결이 가능하다.) $\to$  Build $\to$ ![APIGateway_CreateRESTAPI](/Image/Server/AWS_APIGateway_CreateRESTAPI.png) $\to$  Create API
		- API endpoint type
			- API gateway 가 AWS 네트워크 상에서배포되는 위치를 결정한다.
			- Regional : 현재 선택한 AWS 리전 내에 API 서버가 생성된다. 클라이언트가 해당 리전으로 직접 요청을 보낸다.
			-  Edge-optimiazed : AWS의 CDN 서비스인 CloudFront 네트워크 를 사용한다. 전 세계에 퍼져있는 Edge Locaion 중 유저와 가장 가까운 곳에서 요청을 받아 리전으로 전달한다. (글로벌 서비스 시 지연시간 단축용)
			- Private : VPC 내부망에서만 접속 가능한 비공개 API 이다. 외부 인터넷에서는 접속이 불가능하다.
		- Security policy
			- 클라이언트(언리얼 엔진)와 서버(AWS) 가 HTTPS(SSL) 통신을 할 때 사용할 TLS 프로토콜 버전과 암호화 알고리즘 (Cipher Suite) 을 지정한다.
		- Endpoint Access mode
			- SNI (Server Name Indication) 이라는 기술 표준을 강제할지의 여부를 결정한다. 
				- SNI 는 하나의 서버 IP 가 여러 도메인을 가질 때, 클라이언트가 접속 시 "나는 A 도메인을 찾는다" 고 명시하는 기술.
			- Strick : 클라이언트가 반드시 SNI 를 준수해서 호스트이름을 명확히 보내야만 접속을 허용한다. (보안강화)
			- Basic : SNI 헤더가 없어도 접속을 허용한다. 호환성이 좋다.
		- IP Address type
			- API Gateway 가 수신할 수 있는 IP 프로토콜 버전을 결정한다.
				- IPv4 : IPv4 지원
				- Dualstack : IPv4 와 IPv6 지원
	- API Gateway 를 생성하게 되면 Resource ID 가 하나 주어지는데 이는 API Endpoint 를 만들 때 필요하다.
	- Resoure 는 고유의 이름을 가지고 자신만의 메서드를 가질 수 있다. 그리고 그 메서드 들은 lambda 함수와 연결될 수 있다.

- Resource 생성
	- API Gateway $\to$  APIs $\to$ Resources-GameSessions $\to$ Resources $\to$ Create resource
	- 리소스는 파일 디렉터리와 유사한 구조로 정리할 수 있다.
	- 이전에 만들었던 ListFleets Lambda 를 트리거할 엔드 포인트를 가진 리소스를 만든다.![APIGateway_CreateResource](/Image/Server/AWS_APIGateway_CreateResource.png)
	- Resource 가 생성된다. 해당 리소스를 선택하고 Methods 창의 Create method 를 클릭한다.![AWS_APIGateway_Dashboard](/Image/Server/AWS_APIGateway_Dashboard.png)
	- ![APIGateway_Resource_CreateMethod](/Image/Server/AWS_APIGateway_Resource_CreateMethod.png)
		- 지금 연결할 Lambda 의 목적은 GameLift 에서 정보를 가져오는 역할만 하기 때문에 GET 으로 설정한다.
		- Integration Type 은 해당 API 주소(엔드포인트) 로 request 가 들어왔을 때 누가 일을 처리할 것인가 를 정하는 곳이다. 지금의 경우 미리 만들어둔 ListFleets Lambda 가 실행되기를 원하기 때문에 Lambda function 을 선택한다.
		- lambda proxy integration
			- Proxy On : API Gateway 가 아무일도 안 하고, 클라이언트의 Request 를 있는 그대로 통째로 Lambda 에게 넘긴다.
			- Proxy Off : API Gateway 가 중간에서 Request 데이터를 가공하거나 거를 수 있다. 이는 나중에 API Gateway 단에서 보안 설정이나 데이터 매핑을 직접 제어하겠다는 의도가 있다.
		- Lambda function
			- Region - Function
			- Region : 람다함수가 존재하는 리전을 선택
			- Function 람다 선택
		- Integration timeout
			- 응답 대기 시간으로, 람다 함수가 일정 시간동안 응답이 없으면 API Gateway 가 에러(time out) 을 내고 연결을 끊겠다는 뜻. 최대 대기 한계는 29초로 사진과 같이 29000 으로 표현
		- Method request settings (메서드 요청 설정)
			- `Authorization`을 설정하면, 로그인 안 한 사람은 아예 이 API를 호출 못 하게 막을 수 있다.
		- HTTP request headers (HTTP 요청 헤더)
			- 인증 정보를 담아 보낼 때 사용.
		- Request body
			- 서버에 저장할 데이터(JSON).

- API Gateway $\to$ Resource $\to$ Get Method 의 실행 흐름 (Method Execution)
	1. Method Request (메서드 요청)
		- 클라이언트(언리얼 엔진 등) 이 API 에 접근할 때 가장 먼저 거치는 public interface 계층.
		- 유효성 검사와 인증 을 진행.
			- 인증 : 클라이언트가 유효한 토큰이나 API 키를 가지고 있는지 확인.
			- 검사 : 요청에 필수적인 파라미터나 헤더가 포함되어 있는지 데이터 형식을 검사.
	2. Integraion Request (통합 요청)
		- API Gateway 가 백엔드 서비스 (지금의 경우 Lambda) 와 통신하기 위해 데이터를 구성하는 계층.
		- 데이터 매핑 및 백엔드 호출을 진행
			- 클라이언트가 보낸 HTTP 요청 데이터(JSON 등) 을 람다 함수가 이해할 수 있는 형태 (Event 객체) 로 변환 (Mapping) 한다.
			- 만약 Lambda Proxy[^1: ㄴㅇ리달어랴미] 가 꺼져 있다면, 여기서 템플릿을 사용해 데이터를 가공해서 넘겨준다.
			- 실제로 람다 함수를 트리거(실행) 시키는 단계이다.
	3. Integration Response (통합 응답)
		- 백엔드 (지금의 경우 Lambda)의 실행 결과를 API Gateway 가 처음으로 수신하는 계층.
		- 결과 해석 및 에러 매핑
			- 람다 함수가 반환한 결과값이나 에러 메시지를 받는다.
			- Regex(정규식) 을 사용하여 람다의 에러 문자열을 HTTP 상태 코드 로 매칭한다.
	4. Method Response (메서드 응답)
		- 클라이언트에게 최종적으로 전달될 HTTP 응답을 정의하는 계층
		- 응답 규격 정의 및 헤더 설정.
			- 클라이언트가 받게 될 최종 HTTP 상태 코드를 정의
			- CORS 헤더와 같이 브라우저나 클라이언트가 필요로 하는 응답 헤더를 최종적으로 붙인다.
			- 응답 데이터의 모델 (JSON 스키마) 을 정의하여 문서화
	- TEST
		- AWS 콘솔 내부에서 제공하는 API 시뮬레이더
		- 외부 툴 없이 API 로직을 즉시 검증한다. 실행 버튼을 누르면 위의 4단계(Method Req $\to$  Integ Req $\to$  Lambda $\to$  Integ Res $\to$  Method Res)를 실제로 수행하고, 각 단계별 **로그(Logs)**를 화면에 보여주어 디버깅에 필수적이다.
