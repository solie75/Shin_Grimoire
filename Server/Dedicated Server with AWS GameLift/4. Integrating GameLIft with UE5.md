
1. Build.cs 에 PublicDependencyModuleNames.AddRange() 에 "GameLiftServerSDK" 를 추가.
2. WITH_GAMELIFT 전처리기 플래그
	1. 클라이언트 빌드에 GameLift 백엔드를 제어하는 코드가 들어가면 안되기 때문에 WITH_GAMELIFT 라는 전처리기 플래그를 선언하고 다음의 조건이 둘 다 true 인 경우에만 활성화 한다.
		1. Target.Type == TargetRules.TargetType.Server
		2. The plugins found the Amazon GameLift Server SDK binaries. (프로젝트 플러그인에서 GameLift Server SDK 바이너리를 발견했을 때)
3. GameMode 생성
	1. 템플릿에 존재하는 AShooterGameModeBase 를 상속 받은 GameMode 생성.
```c++
UCLASS()  
class FPSTEMPLATE_API AShooterGameModeBase : public AGameMode  
{  
    GENERATED_BODY()  
public:  
    AShooterGameModeBase();  
    virtual void Tick(float DeltaTime) override;  
    virtual void StartPlayerElimination(float ElimTime, ACharacter* ElimmedCharacter, class APlayerController* VictimController, APlayerController* AttackerController);  
    UPROPERTY()  
    TMap<APlayerController*, FTimerHandle> Timers;  
    virtual void PlayerEliminated(ACharacter* ElimmedCharacter, class APlayerController* VictimController, APlayerController* AttackerController);  
    virtual void RequestRespawn(ACharacter* ElimmedCharacter, AController* ElimmedController);  
  
  
    UPROPERTY(EditDefaultsOnly, Category="Respawning")  
    float RespawnTime;  
};
```
$\to$ 생성
```c++
#pragma once  
  
#include "CoreMinimal.h"  
#include "ShooterGameModeBase.h"  
#include "GameLiftServerSDK.h"  
#include "ShooterGameMode.generated.h"  
  
DECLARE_LOG_CATEGORY_EXTERN(LogShooterGameMode, Log, All);  
  
UCLASS()  
class FPSTEMPLATE_API AShooterGameMode : public AShooterGameModeBase  
{  
    GENERATED_BODY()  
public:  
    AShooterGameMode();  
  
protected:  
    virtual void BeginPlay() override;  
  
private:  
    FProcessParameters ProcessParameters; 
    
    void InitGameLift();
};
```

```c++
#include "Game/ShooterGameMode.h"  
  
#include "HLSLTree/HLSLTreeTypes.h"  
  
AShooterGameMode::AShooterGameMode()  
{  
    }  
  
void AShooterGameMode::BeginPlay()  
{  
    Super::BeginPlay();  
  
#if WITH_GAMELIFT  
    InitGameLift();  
#endif  
}  
  
void AShooterGameMode::InitGameLift()  
{  
    UE_LOG(LogShooterGameMode, Log, TEXT("Initializing the GameLift Server"));  
  
    FGameLiftServerSDKModule* GameLiftServerSDKModule = &FModuleManager::LoadModuleChecked<FGameLiftServerSDKModule>(FName("GameLiftServerSDK"));  
    //Define the server parameters for a GameLift Anywhere fleet. These are not needed for a GameLift managed EC2 fleet.  
    FServerParameters ServerParameters;  
  
    //Authtoken returned from the 'aws gamelift get-compute-auth-token" API. Note this will expire and require a new call to the API after 15 minutes.  
    if (FParse::Value(FCommandLine::Get(), TEXT("-authtoken="), ServerParameters.m_authToken))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("AUTH_TOKEN : %s"), *ServerParameters.m_authToken)  
    }    // The Host/compute-name of the GameLift Anywhere instance.  
    if (FParse::Value(FCommandLine::Get(), TEXT("-hostid="), ServerParameters.m_hostId))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("HOST_ID: %s"), *ServerParameters.m_hostId)  
    }    //the Anywhere Fleet ID.  
    if (FParse::Value(FCommandLine::Get(), TEXT("-fleetid="), ServerParameters.m_fleetId))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("FLEET_ID: %s"), *ServerParameters.m_fleetId)  
    }    // The WebSocket URL (GameLiftServiceSdkEndpoint)  
    if (FParse::Value(FCommandLine::Get(), TEXT("-websocketurl="), ServerParameters.m_webSocketUrl))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("WEBSOCKET_URL: %s"), *ServerParameters.m_webSocketUrl)  
    }}
```

- FProcessParameters
```c++
DECLARE_DELEGATE_OneParam(FOnStartGameSession, Aws::GameLift::Server::Model::GameSession);  
DECLARE_DELEGATE_OneParam(FOnUpdateGameSession, Aws::GameLift::Server::Model::UpdateGameSession);  
DECLARE_DELEGATE_RetVal(bool, FOnHealthCheck);  
  
struct GAMELIFTSERVERSDK_API FProcessParameters {  
    FOnStartGameSession OnStartGameSession;  
    FOnUpdateGameSession OnUpdateGameSession;  
    FOnHealthCheck OnHealthCheck;  
    FSimpleDelegate OnTerminate;  
    int port = -1;  
    TArray<FString> logParameters;  
  
    void OnTerminateFunction() {  
        this->OnTerminate.ExecuteIfBound();  
    }  
    bool OnHealthCheckFunction() {  
        if (this->OnHealthCheck.IsBound()){  
            return this->OnHealthCheck.Execute();  
        }        return false;  
    }  
    void OnActivateFunction(Aws::GameLift::Server::Model::GameSession gameSession) {  
        this->OnStartGameSession.ExecuteIfBound(gameSession);  
    }  
    void OnUpdateFunction(Aws::GameLift::Server::Model::UpdateGameSession updateGameSession) {  
        this->OnUpdateGameSession.ExecuteIfBound(updateGameSession);  
    }};
```

- FProcessParameters 는 게임 서버 프로세스 를 GameLift 서비스에 등록하고 관리하는 데 필요한 매개변수 (Parameters) 를 담고 있다.
- 해당 구조체의 가장 중요한 것은 'GameLift 서비스 와의 통신을 위한 Callback 함수를 가지고 있다는 것이다.'
- 구조체 주요 요소
	- 델리게이트 (Callbacks/Hooks) : GameLift 가 서버에 특정 작업을 요청할 때 서버가 응답할 수 있도록 설계된 함수 포인터 역할을 하는 델리게이트 들이다.
		- `OnStartGameSession` (델리게이트 타입: `FOnStartGameSession`)
		- `OnUpdateGameSession` (델리게이트 타입: `FOnUpdateGameSession`)
		- `OnHealthCheck` (델리게이트 타입: `FOnHealthCheck`)
		- `OnTerminate` (델리게이트 타입: `FSimpleDelegate`)
		- 해당 델리게이트를 통해 GameLift 액션에 반응하여 작업을 수행할 수 있다.
	- 설정값
		- Port : 게임 서버가 클라이언트의 접속을 기다릴 포트 번호 (기본값 : -1)
		- LogParameters : 로그 파일 경로 등 로깅 관련 매개변수를 담는 배열
	- 내부 함수 (Delegate Execution)
		- `OnActivateFunction`, `OnUpdateFunction`, `OnTerminateFunction`, `OnHealthCheckFunction` 등은 실제로 GameLift 서버 SDK 가 언리얼 서버에 요청을 보낼 때, 등록된 콜백(델리게이트)을 호출(ExecuteIfBound()) 를 하기 위해 사용하는 래퍼(Wrapper) 함수들이다.
- GameLIft 에서의 역할 : Callback 연결
	- FProcessParameter 의 핵심역할은 GameLift와 언리얼 서버 간의 양방향 통신 채널을 구축하는 것이다.
		- GameLift 액션 발생 : GameLift 서비스에서 게임 세션이 시작되거나, 서버 상태를확인해야 하거나, 서버를 종료해야 하는 등. 특정 이벤트(액션)이 발생한다.
		- 델리게이트 브로드캐스트 : GameLift SDK 는 이러한 액션에 반응하여 OnStartGameSession 과 같은 해당 델리게이트를 브로드 캐스트(실행) 한다.
		- 서버 반응(바인딩) : 언리얼 개발자는 이 FProcessParameters 의 멤버 델리게이트에 함수나 람다를 바인딩 하여 연결해 둔다.
		- 작업 수행 : 연결된 함수/ 람다는 즉시 실행되어, 서버가 GameLift 의 요청에 따라 필요한 조치 ( 게임 월드 생성, 상태 보고 등)를 취하게 된다.
- GameMode 의 멤버 변수로 선언하는 이유
	- "Process Parameter 는 프로그램의 수명동안 Scope 내에 남아 있어야 한다."
	- 콜백 생명주기 (Callback Lifetime) : FProcessParameters 는 GameLIft 가 서버와 통신하는 동안 콜백을 실행하기 위해 항상 접근가능해야 한다.
	- GameMode 의 생명주기 : 언리얼 엔진에서 GameMode 클래스는 게임 세션이 지속되는 동안 가장 오래 살아 남는 핵심 클래스 중 하나이다.
	- 즉, FProcessParameters 를 GameMode 의 멤버 변수로 두면, GameMode 가 살아 있는 한 (즉, 서버 프로세스가 실행되는 한) tmzhvm sodp dkswjsgkrp dbwlehlau, GameLift 가 언제든 콜백을 호출할 수 있도록 보장한다.
- 이후 개발자는 InitGameLift 와 같은 함수를 만들어 ProcessParameters 의 델리게이트에 실제 로직을 담은 함수들을 바인딩하게 된다.

- InitGameLift()
	- 해당 함수는 GameLift SDK 를 로드하고, 서버 프로세스를 GameLift 서비스에 등록하는 데 필요한 매개변수들을 커맨드 라인 인수를 통해 수집하는 역할을 한다.
	- 함수 주요 역할 : 모듈 로드 및 Anywhere Fleet 파라미터 수집
		- GameLift SDK 모듈 로드 : Unreal Engine 의 모듈 시스템을 사용하여 GameLift 서버 SDK 모듈을 메모리에 로드한다.
		- Anywhere Fleet 파라미터 수집 : 서버 프로세스가 GameLift 서비스에 연결하는 데 필요한 인증 및 식별 정보를 커맨드 라인 인수 (Command Line Arguments) 에서 읽어봐 FServerParameters 구조체에 저장ㅎ나다.
		- Fleet 이란?
			- AWS 에서 Fleet 은 게임 서버를 호스팅하는 컴퓨팅 리소스의 집합을 의미한다. 이는 서버 프로세스를 실생하는 실제 인스턴스(가상머진 또는 물리적 장치) 그룹이다.
			- GameLift 관리형 EC2 Fleet : AWS 클라우드의 EC2 인스턴스를 사용하여 서버를 호스팅하는 일반적인 방식. (이 경우 서버 파라미터 불필요)
			- GameLift Anywhere Fleet : 개발자의 PC 나 자체 데이터 센터 등 외부 컴퓨팅 리소스에서 서버를 호스팅하고 GameLift 서비스를 사용하여 관리하는 방식 (이 경우 FServerParameters 필수)
		- 커맨드 라인 인수
			- 서버 빌드를 실행할 때 실행 파일 경로 뒤에 붙여서 전달하는 값들.
			- ShooterServer.exe -authtoken=ABCDE12345 -hostid=MyDevPC ...
			- InitGameLift 함수는 이 FParse::Value 기능을 사용하여 실행 시 전달된 인증 토큰, 호스트 ID 등의 민감하고 환경 의존적인 정보를 안전하게 읽어온다.
		- 인증 토큰
			- Anywhere Fleet 서버가 GameLift 서비스에 연결할 때 '자신이 이 플릿에 연결할 권한이 있는 유요한 서버다' 라는 것을 증명하기 위해 필요한 임시 토큰. 이 토큰은 aws gamelift get-compute-auth-token API 호출을 통해 얻는다.
		- FModuleManager
			- Unreal Engine 의 모듈을 관리하는 클라스이다. .uproject 파일에서 지정된 모든 기능을 관리하며, 여기서 GameLift SDK 의 기능을 사용하기 위해 모듈을 명시적으로 로드하는 데 사용된다.

| **코드 라인**                                                                                                                                       | **문법/개념**        | **역할 및 설명**                                                                                                                                                                                                                                                                            |
| ----------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `UE_LOG(LogShooterGameMode, Log, ...)`                                                                                                          | **매크로 (UE_LOG)** | `InitGameLift` 함수 실행 시작을 알리는 **로그**를 출력합니다. (`LogShooterGameMode` 카테고리, `Log` 레벨 사용).                                                                                                                                                                                                  |
| `FGameLiftServerSDKModule* GameLiftServerSDKModule = &FModuleManager::LoadModuleChecked<FGameLiftServerSDKModule>(FName("GameLiftServerSDK"));` | **언리얼 모듈 시스템**   | 1. **`FModuleManager::LoadModuleChecked<T>()`**: 지정된 모듈(`GameLiftServerSDK`)을 찾아 메모리에 강제로 로드합니다. 모듈을 찾지 못하면 크래시를 발생시켜 개발자가 문제를 알도록 합니다. (Checked). 2. **`&` 연산자**: 반환된 모듈 객체의 주소를 가져와 포인터(`GameLiftServerSDKModule`)에 저장합니다. 이는 이후 **`InitSDK` 함수를 호출**하여 GameLift SDK를 초기화하는 데 사용됩니다. |
| `FServerParameters ServerParameters;`                                                                                                           | **구조체 선언**       | `FServerParameters` 타입의 **지역 변수**를 선언합니다. 이 구조체는 Anywhere Fleet 연결에 필요한 `m_authToken`, `m_hostId`, `m_fleetId`, `m_webSocketUrl` 등의 문자열 값을 담는 단순한 컨테이너입니다.                                                                                                                             |
| `//Define the server parameters for a GameLift Anywhere fleet...`                                                                               | **주석 (정보 제공)**   | 이 파라미터는 **GameLift Anywhere Fleet** (개발자 로컬 머신 등 자체 컴퓨팅 리소스)에만 필요하며, **GameLift 관리형 EC2 Fleet**에는 필요하지 않음을 명시하여 두 플릿 타입의 차이를 구분해 줍니다.                                                                                                                                                  |
| `if (FParse::Value(FCommandLine::Get(), TEXT("-authtoken="), ServerParameters.m_authToken))`                                                    | **커맨드 라인 파싱**    | 1. **`FCommandLine::Get()`**: 실행 시 전달된 전체 커맨드 라인 인수에 접근합니다. 2. **`FParse::Value()`**: 커맨드 라인 인수 목록에서 **`-authtoken=`**으로 시작하는 문자열을 찾습니다. 3. **성공 시**: 그 뒤에 오는 값을 `ServerParameters.m_authToken` 변수(FString)에 저장하고 `true`를 반환합니다. 4. **`if` 문**: 인수를 성공적으로 찾았을 경우에만 내부의 로그 코드가 실행됩니다.   |
| `UE_LOG(..., Log, TEXT("AUTH_TOKEN : %s"), *ServerParameters.m_authToken)`                                                                      | **로그 출력**        | 커맨드 라인에서 **인증 토큰(Auth Token)** 값을 성공적으로 수집했다는 것을 확인하기 위해 그 값을 출력합니다. 이는 디버깅 용도로, 토큰이 **유효함**을 증명하는 것은 아니고 **전달되었음**만 증명합니다.                                                                                                                                                            |
| 나머지 `if` 블록 (HostID, FleetID, WebSocketURL)                                                                                                     | **커맨드 라인 파싱**    | 위와 동일한 문법을 사용하여 **호스트 ID, 플릿 ID, 웹소켓 URL** 인수를 차례로 파싱하고 `ServerParameters` 구조체에 저장합니다. 이 4가지 정보는 Anywhere Fleet 서버가 GameLift 서비스에 **자신을 식별하고 인증**받는 데 필수적입니다.                                                                                                                          |



- ServerParameter 를 따로 함수로 만든다.
```c++
void AShooterGameMode::SetServerParameters(FServerParameters& OutServerParameters)  
{  
    //Authtoken returned from the 'aws gamelift get-compute-auth-token" API. Note this will expire and require a new call to the API after 15 minutes.  
    if (FParse::Value(FCommandLine::Get(), TEXT("-authtoken="), OutServerParameters.m_authToken))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("AUTH_TOKEN : %s"), *OutServerParameters.m_authToken)  
    }    // The Host/compute-name of the GameLift Anywhere instance.  
    if (FParse::Value(FCommandLine::Get(), TEXT("-hostid="), OutServerParameters.m_hostId))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("HOST_ID: %s"), *OutServerParameters.m_hostId)  
    }    //the Anywhere Fleet ID.  
    if (FParse::Value(FCommandLine::Get(), TEXT("-fleetid="), OutServerParameters.m_fleetId))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("FLEET_ID: %s"), *OutServerParameters.m_fleetId)  
    }    // The WebSocket URL (GameLiftServiceSdkEndpoint)  
    if (FParse::Value(FCommandLine::Get(), TEXT("-websocketurl="), OutServerParameters.m_webSocketUrl))  
    {       UE_LOG(LogShooterGameMode, Log, TEXT("WEBSOCKET_URL: %s"), *OutServerParameters.m_webSocketUrl)  
    }  
    //The PID of the running process  
    OutServerParameters.m_processId = FString::Printf(TEXT("%d"), GetCurrentProcessId());  
    UE_LOG(LogShooterGameMode, Log, TEXT("PID : %s"), *OutServerParameters.m_processId);  
}  
  
void AShooterGameMode::InitGameLift()  
{  
    UE_LOG(LogShooterGameMode, Log, TEXT("Initializing the GameLift Server"));  
  
    FGameLiftServerSDKModule* GameLiftServerSDKModule = &FModuleManager::LoadModuleChecked<FGameLiftServerSDKModule>(FName("GameLiftServerSDK"));  
    //Define the server parameters for a GameLift Anywhere fleet. These are not needed for a GameLift managed EC2 fleet.  
    FServerParameters ServerParameters;  
  
    SetServerParameters(ServerParameters);  
  
    GameLiftServerSDKModule->InitSDK(ServerParameters);  
}
```

- InitSDK
	- 내 컴퓨터나 자체 서버에서 실행할 때 (GameLift Anywhere Fleet)
		- InitSDK(ServerParameger) 를 사용해야 한다.
		- AWS 외부의 장비이거나 직접 관리하는 장비이므로, 서버가 GameLift 와 통신하기 위한 정보(ServerParameter) 를 직접 넣어줘야 한다.
		- 현재 위의 코드는 ServerParameters 를 인자로 넣고 있으므로 Anywhere 또는 로컬 테스트 를 따르고 있다.
	- AWS 클라우드 위에서 실행할 때 (GameLift Managed EC2 Fleet)
		- 클라우드 가상 머신에서 호스팅할 때
		- 인자 없이 InitSDK() 만 호출하면 된다.
		- AWS 가 환경을 관리해 주기 때문에 필요한 정보가 이미 설정되어 있어, 파라미터를 넘겨줄 필요가 없다.
- ProcessReady
	- SDK 초기화가 끝났으면 , 서버 프로세스가 게임 세션을 호스팅할 준비가 되어싿고 GameLift 에 알려야 한다. 이때 ProcessReady() 함수를 호출하며, 한 프로세스당 딱 한 번만 호출해야한다.
		- 포트 번호 (Port Number)
			- 서버 프로세스가 사용중인 포트. GameLift 는 이 포트 정보를 게임 클라이언트에게 전달하여 플레이어들이 접속할 수 있게 한다.
		- 로그 파일 위치 (Log Paths)
			- 서버가 생성하는 로그 파일들이 저장된 경로. GameLift 는 이 파일들을 임시로 저장해 두었다가, 나중에 콘솔이나 API(GetGameSessionLogUrl) 를 통해 개발자가 다운로드 할 수 있게 해준다.
			- 주의 [[#컨테이너 환경|(컨테이너 플릿 사용 시)]]
				- 컨테이너 환경에서는 로그 경로를 지정할 필요가 없다. 대신 표준 출력 (Standard Output) 으로 로그를 보내면 자동으로 캡쳐된다.
		- 콜백 함수 구현 (Callback Functions)
			- GameLift 가 서버에게 특정 작업을 지시할 때 호출하는 함수들. 이 함수들은 반드시 게임 서버 코드 내에 구현되어 있어야 한다.
			- OnStartGameSession (필수)
				- CreateGameSession() 요청이 들어왔을 때 호출된다. 즉 '게임을 시작해라' 라는 신호이다.
				- GameSession 은 GameLift 가 추적 관리하며, 세션 내 플레이어 수, 해당 세션을 호스팅하는 서버의 Ip 주소 및 포트 등의 정보를 담고 있다.
			- OnProcessTerminate (필수)
				- GameLift 가 서버 프로세스를 강제로 종료할 때 호출된다. 서버가 안전하게 종료 될 수 있도록 마무리 작업을 여기서 한다.
			- OnHealthCheck (선택)
				- GameLift 가 주기적으로 서버가 살아있는지 물어보는 함수. 서버의 건강 상태를 보고한다.
			- OnUpdateGameSession
				- 매치메이킹 백필(Match Backfill, 빈 자리에 사람 채우기) 기능 등을 사용할 때 , 갱신된 세션 정보를 받을 때 사용한다.
				- FlexMatch 라는 특정 서비스 타입을 위한것으로, 플레이어를 세션에 자동으로 연결해 주도록 설계 되었다.

- 즉 InitSDK 로 GameLift 과 연결한다 $\to$  ProcessReady  로 내 포트와 로그 위치를 알려주는 것으로 준비되었다고 알린다. $\to$ 그 후에 미리 정의해 둔 콜백 함수를 통해 GameLift 의 지시 (게임 시작, 종료 등) 을 기다리는 구조이다.

##### 컨테이너 환경

- 내 컴퓨터에서는 게임 서버가 잘 돌아가는데 타 컴퓨터나 AWS 서버에 올리면 특정 파일이 없다며 에러가 날 때가 있는데 이는 컴퓨터 마다 설정이 달라서 그렇다.
- 이는 내 게임 서버 프로그램 뿐 아니라, 서버가 돌아가는 데 필요한 모든 환경 (운영체제 설정, 라이브러리, 파일 등) 을 하나의 '박스(컨테이너)'에 담아버리는 기술이다.
- 이 '박스' 를 내 컴퓨터에서 열든, AWS 에서 열든 내용물이 완벽하게 똑같이 작동한다. 이 박스가 설치되는 곳이 컨테이너 환경이다. (ex Docker 등)

- Container Fleet
	- GameLift Fleet : 게임 서버를 돌리는 컴퓨터 (EC2) 의 묶음이다.
	- Container Fleet : 일반적인 컴퓨터에 게임 파일을 그냥 복사해서 싱행하는 게 아니라, 위에서 만든 컨테이너'박스' 를 잔뜩 실어서 실행하는서버 부대를 말한다.
- Standard Output
	- 일반적인 로그(파일 저장) 보통은 ServerLog.txt 같은 파일을 만들어서 거기다 글을 쓴다.
	- 표준출력 : 프로그램을 실행했을 때, 검은색 콘솔 창(CMD 창)에 글자가 주르륵 올라가는것. 그것이 표준출력이다.
		- C++ 의 std::cout << "Hello"; 나 printf("Hello") 가 표준 출력으로 내보내는 것이다.
		- 언리얼에서는 로그 설정에 따라 화면에 출력되는 로그들이 여기에 해당한다.
- Capture
	- 원래 방식 (파일) 은 GameLift 한테 Server.log 를 가져가라고 경로를 알려줘야 했다.
	- 컨테이너 방식 (캡쳐) 은 경로를 알려줄 필요가 없다. 서버가 표준 출력 으로 "플레이어 접속함" 이라고 외치면 "GameLift 시스템 이 옆에서 듣고 있다가 자동으로 그 내용을 받아 적어서 저장한다. 이 과정을 캡쳐 라고 한다.


##### Callback Function

```c++
void AShooterGameMode::InitGameLift()  
{  
    UE_LOG(LogShooterGameMode, Log, TEXT("Initializing the GameLift Server"));  
  
    FGameLiftServerSDKModule* GameLiftServerSDKModule = &FModuleManager::LoadModuleChecked<FGameLiftServerSDKModule>(FName("GameLiftServerSDK"));  
    //Define the server parameters for a GameLift Anywhere fleet. These are not needed for a GameLift managed EC2 fleet.  
    FServerParameters ServerParameters;  
  
    SetServerParameters(ServerParameters);  
  
    GameLiftServerSDKModule->InitSDK(ServerParameters);  
  
    auto OnGameSession = [=](Aws::GameLift::Server::Model::GameSession gameSession)  
    {       FString GameSessionId = FString(gameSession.GetGameSessionId());  
       UE_LOG(LogShooterGameMode, Log, TEXT("GameSession Initializing : %s"), *GameSessionId);  
       GameLiftServerSDKModule->ActivateGameSession();  
    };  
    ProcessParameters.OnStartGameSession.BindLambda(OnGameSession);  
  
    auto OnProcessTerminate = [=]()  
    {  
       UE_LOG(LogShooterGameMode, Log, TEXT("Game Server Process is terminating"));  
       GameLiftServerSDKModule->ProcessEnding();  
    };  
    ProcessParameters.OnTerminate.BindLambda(OnProcessTerminate);  
  
    auto OnHealthCheck = []()  
    {  
       UE_LOG(LogShooterGameMode, Log, TEXT("Performing Health Check"));  
       return true;  
    };  
    ProcessParameters.OnHealthCheck.BindLambda(OnHealthCheck);  
}
```

- OnStartGameSession - ActivateGameSession()
	- 람다 함수로 GameLift 가 게임 세션 시작을 명령할 때 우리 서버가 수행해야할 행동 지침을 지정한다.
	- Fstring GameSessionId 에 GameLift 가 넘겨준 GameSession 객체에서 ID 를 꺼내 언리얼 문자열로 변환한다.
	- UE_LOG() : 서버 로그에 게임 세션 초기화 중 : ID 라고 기록을 남긴다
	- GameLIftServerSDKModule $\to$ ActivateGameSession()
		- 이 함수를 호출해야만 'GameLift 콘솔에서 이 세션의 상태가 Activating 에서 Active 로 바뀌고 플레이어가 접속할 수 있게 된다.'
	- BindRambda : 람다를 GameLift 설정(ProcessParameters)에 등록한다.

- OnTerminate - ProcessEnding();
	- 이 함수가 호출되면 GameLift 는 해당 게임 세션과 서버 프로세스의 상태를 Terminated(종료됨) 으로 즉시 변경한다.
	- 상태가 Terminated 가 되면, 이 서버는 더 이상 새로운 플레이어를 받을 수 없다. (새 플레이어를 받으려면 아예 새 게임 세션을 만들어야 한다.)
	- 리소스 재활용 : GameLIft 에게 '이 게임 세션이 끝났으니, 이 호스팅 리소스(서버 자원) 을 정리하고 재활용해도 좋다' 라고 알리는 신호이다.
	- 좀비 세션 방지 : 만약 서버가 크래시가 나도 ProcessEnding 을 호출하지 않으면, GameLift 는 서버가 살아 있다고 착각하여 세션을 한동안 유지시킨다 (데이터 수신이 끊겨서 알아차릴 때까지). 따라서 개발자가 의도적으로 세션을 깔끔하게 종료하려면 반드시 해당 함수를 호출해야 한다.
	- ProcessEnding() 함수를 호출하기 직전에 람다 함수에서 세션 종료 직전에 해야할 작업을 처리한다.
	- ProcessEnding() 이 호출되기 직전에 주로 수행되어야 하는 작업들
		1. 플레이어들의 최종 점수나 아이템 정보를 데이터베이스(DB) 에 저장.
		2. 다른 백엔드 서비스와 통신하여 상태 동기화.
		3. 중요한 로그 파일 저장.

- OnHealthCheck
	- GameLift 는 약 60초마다 우리 서버에게 살아 있는지를 물어본다 (콜백 호출)
	- 서버는 반드시 60초 안에 대답해야 한다. 이때의 응답은 true(이상 없음), false(이상 있음)으로 한다.
	- 해당 콜백 함수를 구현하지 않으면 GameLoft 는 "서버가 켜져만 있으면 무조건 '이상 없다' "라고 가정한다.
	- 구현 이유
		- 좀비 서버 방지
			- 만약 서버가 크래시가 나서 멈추거나, ProcessEnding 없이 비정상 종료되면 더 이상 true 를 보낼 수 없다.
			- GameLift 는 60초 동안 대답이 없으면 이를 감지하고, 추후 확인 때에 3번 연속으로 문제가 발생하면 자동으로 서버를 제거 한다.
			- 즉, 고장난 서버가 AWS 리소스(비용) 을 계속 잡아먹는 것을 막아준다.
		- 복잡한 로직 없이 true 만 반환하도록 만들어도 서버가 완전히 멈췄을 때 를 감지하여 재부팅 시키는 안전장치 역할을 하기 때문이다.
	- 즉, OnHealthCheck 는 60초마다 서버 생존을 확인하는 기능으로, 선택 사항이긴 하지만, 서버가 먹통이되었을 때 자동으로 끄고 리부팅(리소스 정리) 시키기 위해, 무조건 true 만 반환하더라도 구현해 두는 것이 좋다.

- Port
	- 언리얼 엔진 게임 서버가 사용하는 기본 포트는 7777이다.
	- 하드코딩이 아니라 포트 값을 전달하도록 한다. 그렇게 하면 GameLift 게임 세션 인스턴스가 수신 대기해야 할 포트를 지정할 수 있다. 원한다면 GameLift의 단일 가상 머신에서 서로 다른 포트로 여러 서버 프로세스를 시작할 수도 있다.
	1. 명령줄을 입력하여 포트가 전달 되지 않았을 경우 언리얼 엔진에 설정된 프로젝트의 기본 포트값을 가져오도록 한다.  int32 Port = FURL::UrlConfig.DefultPort;
	2. 사용자가 지정한 포트에서 서버 프로세스를 시작하고, 커맨드 라인 인수를 전달하여 게임 모드에 그 포트가 무엇인지 알려주고 싶은 경우 [[Engine Initialization & Control#^b58b28 | FCommandLine 사용]] + [[FString#^3f35f6|port 저장]]

```c++
void AShooterGameMode::ParseCommandLinePort(int32& OutPort)  
{  
    TArray<FString> CommandLineTokens;  
    TArray<FString> CommandLineSwitches;  
    FCommandLine::Parse(FCommandLine::Get(), CommandLineTokens, CommandLineSwitches);  
  
    for (const FString& Switch : CommandLineSwitches)  
    {       
	    FString Key;  
	    FString Value;  
	    if (Switch.Split(TEXT("="), &Key, &Value))  
	    {          
		    if (Key.Equals(TEXT("port"), ESearchCase::IgnoreCase))  
	        {             
		        OutPort = FCString::Atoi(*Value);  
	            return;  
	        }
		}      
    }
}

void AShooterGameMode::InitGameLift()
{
	...
	ProcessParameters.OnHealthCheck.BindLambda(OnHealthCheck);
	
	int32 Port = FURL::UrlConfig.DefaultPort;  
  
	ParseCommandLinePort(Port);  
	  
	ProcessParameters.port = Port;
}
```